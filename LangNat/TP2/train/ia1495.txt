pour les articles homonymes , voir prolog ( homonymie ) . prolog est l ’ un des principaux langages de programmation logique . le nom prolog est un acronyme de programmation en logique . il a été créé par alain colmerauer et philippe roussel vers 1972 . le but était de créer un langage de programmation où seraient définies les règles logiques attendues d&apos; une solution et de laisser le compilateur la transformer en séquence d&apos; instructions . l&apos; un des gains attendus était une facilité accrue de maintenance des applications , l&apos; ajout ou la suppression de règles au cours du temps n&apos; obligeant pas à réexaminer toutes les autres . prolog est utilisé en intelligence artificielle et dans le traitement linguistique par ordinateur ( principalement langues naturelles ) . ses règles de syntaxe et sa sémantique sont simples et considérées comme claires ( un des objectifs poursuivis était de procurer un outil aux linguistes ignorant l ’ informatique ) . les premiers résultats obtenus avec prolog suscitèrent quelque temps , dans les années 1980 , des recherches sur une cinquième génération , matérielle et logicielle , d&apos; ordinateurs ( nommée cinquième génération japonaise en raison de l&apos; engagement important du miti sur le projet ) . l&apos; effort engagé fut important , les retombées plus modestes , prolog restant un langage parmi d&apos; autres dans la panoplie du programmeur . prolog est basé sur le calcul des prédicats du premier ordre ; cependant il est restreint dans sa version initiale à n ’ accepter que les clauses de horn ( les versions modernes de prolog acceptent des prédicats plus complexes , notamment avec le traitement de la négation par l&apos; échec ) . l ’ exécution d ’ un programme prolog est effectivement une application du théorème prouvant par résolution du premier ordre . les concepts fondamentaux sont l ’ unification , la récursivité et le retour sur trace . l&apos; algorithme de résolution de prolog est basé sur une extension de la sld-résolution . on peut construire en prolog une base de connaissances dans un ordre indéterminé , puisque seules comptent les relations en présence et non leur séquence d&apos; écriture . prolog peut ensuite résoudre des séries de problèmes logiques relatifs à une telle base de connaissances ( notion base de données déductive ) , problème similaire à la recherche d&apos; une issue ( ou plusieurs ) dans un labyrinthe de contraintes établies . prolog n ’ emploie pas de typage de données au sens habituel des langages de programmation . il n&apos; effectue en effet pas de distinction réelle entre les données du programme et le programme lui-même ( principe de la programmation déclarative ) . ses éléments lexicaux , nommés termes , englobent les types suivants . les textes constants constituent des atomes . un atome est ordinairement constitué d&apos; une chaîne de lettres , nombres et traits bas ( _ ) , commençant par une lettre minuscule . pour introduire un atome non alphanumérique , on l&apos; entoure d&apos; apostrophes : ainsi &apos; + &apos; est un atome , + un opérateur ) . les implémentations courantes de prolog ne s&apos; occupent pas en général de différencier les nombres entiers des flottants . les variables sont indiquées en utilisant un ensemble de lettres , nombres et caractères de soulignement et commençant avec une lettre majuscule . ainsi , x3 comme prix _ unitaire sont des noms de variables admissibles . prolog n&apos; est pas un langage de programmation impératif ; une variable n ’ y est donc pas un contenant auquel on affecte une valeur , mais représente ( comme en mathématiques dans x &gt; 0 ) l&apos; ensemble des valeurs admissibles pour elle dans le cadre des contraintes . le champ initialement indéfini de la variable se précise par l&apos; unification autour des contraintes . une fois la variable unifiée , sa valeur ne peut plus être modifiée au sein d&apos; une même branche d&apos; évaluation . le retour sur trace permet toutefois de revenir sur cette unification dans le cadre de la poursuite de la recherche de valeurs admissibles ( ou de nouvelles valeurs admissibles ) , dans le cadre d&apos; une exploration exhaustive . la variable anonyme est écrite avec un tiret bas ( _ ) . toute variable dont le nom commence par un tiret bas est également une variable anonyme . c&apos; est , comme le x ou le y de l&apos; algèbre , une variable muette servant d&apos; intermédiaire de calcul . prolog ne peut représenter des données complexes que par termes composés . un terme composé consiste en une tête ( aussi appelée foncteur ) , qui doit être un atome , et des paramètres sans restriction de type . le nombre de paramètres , nommé arité du terme , est en revanche significatif . un terme composé est identifié par sa tête et son arité , et habituellement écrit comme foncteur / arité . le foncteur est aime et l&apos; arité 2 , le terme composé s&apos; écrit aime / 2 . le foncteur est f et l&apos; arité 2 , le terme composé s&apos; écrit f / 2 . le foncteur est initialisation et l&apos; arité 0 , le terme composé s&apos; écrit initialisation / 0 . un atome est donc un terme composé d&apos; arité 0. si t est une liste et h est un élément , alors le terme &apos; .&apos; ( h , t ) est une liste . le premier élément , appelé la tête , est h , suivi par les contenus du reste de la liste , indiqué comme t ou queue . la totalité d ’ une liste peut être traitée en agissant sur le premier élément , et ensuite sur le reste de la liste , par récursivité , comme en lisp . pour la commodité du programmeur , les listes peuvent être construites et déconstruites de diverses manières . les chaînes de caractères sont en général écrites comme une séquence de caractères entourés par des apostrophes . elles sont souvent représentées en interne par une liste de codes ascii . la programmation en prolog est très différente de la programmation dans un langage impératif . en prolog , on alimente une base de connaissances de faits et de règles ; il est alors possible de faire des requêtes à la base de connaissances. chat ( tom ) . ? - chat ( tom ) . ? - chat ( x ) . l&apos; interpréteur répond qu&apos; il n&apos; en trouve pas . cette recherche d&apos; autres solutions repose sur un modèle d&apos; exécution non-déterministe ( au sens du non-déterminisme des automates non-déterministes ) avec retour sur les différents points de choix et exploration des alternatives non explorées . ? - chat ( vim ) . dans ce dernier exemple , à la question &apos; chat ( vim ) &apos; l&apos; interpréteur répond qu&apos; il ne peut pas prouver ce fait , en prolog il s&apos; agit d&apos; un échec . en faisant l&apos; hypothèse que tous les faits sont connus ( hypothèse du monde clos ) , cela signifie que &apos; vim &apos; n&apos; est pas un chat. pere ( marie , pierre ) . pere ( pierre , marie ) . dans les deux cas , &apos; père &apos; est la tête tandis que &apos; marie &apos; et &apos; pierre &apos; sont les arguments . cependant , dans le premier cas , marie vient en premier dans la liste des arguments , et dans le second c ’ est pierre ( l ’ ordre dans la liste des arguments importe ) . le premier cas est un exemple d ’ une définition dans l ’ ordre verbe-objet-sujet et pourrait se lire avec l&apos; auxiliaire &apos; avoir &apos; : marie a pour père pierre , et le second de verbe-sujet-objet et pourrait se lire avec l&apos; auxiliaire &apos; être &apos; : pierre est le père de marie . comme prolog ne comprend pas le langage naturel , les deux versions sont correctes en ce qui le concerne ; cependant il est important d&apos; adopter des normes de programmation cohérentes pour un même programme . en général , c&apos; est plutôt l&apos; auxiliaire &apos; être &apos; qui est utilisé. famille ( pierre , marie , &#91; arthur , bruno , charlotte &#93; ) . signifie que pierre et marie sont respectivement le père et la mère de 3 enfants : arthur , bruno et charlotte ; &quot; famille &quot; est alors un prédicat à 3 termes , le dernier étant une liste d&apos; un nombre quelconque ( éventuellement nul ) d&apos; enfants. write ( &apos; bonjour &apos; ) . affichera le mot &apos; bonjour &apos; sur le moniteur . de tels prédicats ne relèvent pas à proprement parler de la programmation logique , leur fonctionnalité reposant exclusivement sur leurs effets de bords . d&apos; autres prédicats bâtis dans le langage sont de nature logique , et inclus dans des bibliothèques . ils servent à simplifier le développement en encapsulant des traitements génériques , comme des algorithmes de traitement de listes par exemple . n.b.- sans les prédicats prédéfinis , prolog est parfois appelé pure prolog ( selon le standard iso en anglais : definite prolog ) . lumière ( on ) : - interrupteur ( on ) . père ( x , y ) : - parent ( x , y ) , mâle ( x ) . pour signifier qu&apos; un x est père d&apos; un y si x est parent de y et x est mâle , où &quot; , &quot; indique une conjonction. parent ( x , y ) : - père ( x , y ) ; mère ( x , y ) . pour signifier qu&apos; un x est parent d&apos; un y si x est père de y ou x est mère de y , où &quot; ; &quot; indique une alternative. a : - true . quand l ’ interpréteur reçoit une requête , il recherche les règles ( faits inclus ) dont la partie gauche peut être unifiée avec la requête , et effectue cette unification avec la première règle trouvée. frère _ ou _ sœur ( x , y ) : - parent ( z , x ) , parent ( z , y ) , x \ = y. parent ( x , y ) : - père ( x , y ) . parent ( x , y ) : - mère ( x , y ) . mère ( trude , sally ) . père ( tom , sally ) . père ( tom , erica ) . père ( mike , tom ) . ? - frère _ ou _ sœur ( sally , erica ) . l ’ interpréteur arrive à ce résultat en faisant correspondre la règle frère _ ou _ sœur ( x , y ) en unifiant x avec sally et y avec erica . cela signifie que la demande peut être étendue à parent ( z , sally ) , parent ( z , erica ) . faire correspondre cette conjonction est obtenu en regardant tous les parents possibles de sally . cependant , parent ( trude , sally ) ne mène pas à une solution viable , parce que si trude est substitué pour z , parent ( trude , erica ) devra être vrai , et aucun fait tel ( ou quelque règle qui puisse satisfaire cela ) n&apos; est présent . aussi à la place , tom est substituée pour z , et erica et sally apparaissent être frère _ ou _ sœur néanmoins . la négation logique pure n&apos; existe pas en prolog , on se repose sur la négation par l&apos; échec , qui se note différemment suivant les implémentations de prolog ( nous adopterons la notation par le mot-clé not ( prédicat ) ) . en négation par l&apos; échec , la négation d&apos; un prédicat est considérée comme vrai si l&apos; évaluation du prédicat mène à l&apos; échec ( n&apos; est pas vérifiable ) . dans prolog , la négation par l&apos; échec s&apos; appuie sur l&apos; hypothèse du monde clos : tout ce qui est vrai est connu ou démontrable à partir de ce qui est connu en un temps fini. parent ( jorge , andres ) . parent ( andres , felipe ) . grandparent ( x , y ) : - parent ( x , z ) , parent ( z , y ) . ? grandparent ( jorge , _ ) . % il y a assez d&apos; information pour dire que jorge a un grandparent connu . ? grandparent ( andres , _ ) . ? not ( grandparent ( andres , _ ) ) . prolog est un langage logique , aussi en théorie , on n&apos; a pas à se préoccuper de la façon dont il s ’ exécute . cependant il est parfois prudent de prendre en compte comment l ’ algorithme d ’ inférence agit , pour éviter qu ’ un programme prolog ne dure trop longtemps . par exemple , nous pouvons écrire du code pour compter le nombre d ’ éléments d ’ une liste. elems ( &#91; &#93; , 0 ) . si une liste n ’ est pas vide , alors x est augmenté de un par rapport à y , nombre d ’ éléments dans le reste de la liste ( sans le premier élément ) . dans ce cas , il y a une distinction claire entre les cas dans l ’ antécédent dans les règles. miser ( x ) : - avoirargent ( x ) . miser ( x ) : - avoircrédit ( x ) , not avoirargent ( x ) . si vous avez de l ’ argent , vous continuez à miser . si vous avez tout perdu vous avez besoin d ’ emprunter , ou sinon ... plus de pari. avoirargent ( x ) peut être une fonction très coûteuse , par exemple , si elle peut accéder à votre compte bancaire par l ’ internet . mais c ’ est la même chose pour avoircrédit. miser ( x ) : - avoircrédit ( x ) , not avoirargent ( x ) . miser ( x ) : - avoirargent ( x ) . ce qui est bien , parce que les deux options s ’ excluent l ’ une l ’ autre . cependant vérifier si vous pouvez obtenir un prêt n ’ est pas nécessaire si vous savez que vous avez de l ’ argent . aussi en pratique , les implémentations de prolog testeront d&apos; abord la règle que vous avez écrite en premier. miser ( x ) : - avoirargent ( x ) , ! . miser ( x ) : - avoircrédit ( x ) , not avoirargent ( x ) . miser ( x ) : - avoirargent ( x ) , ! . miser ( x ) : - avoircrédit ( x ) . cela est appelé un opérateur d ’ arrêt rouge , parce qu ’ il est dangereux de faire cela . vous êtes maintenant dépendant du placement correct de l ’ opérateur d ’ arrêt et l ’ ordre des règles pour déterminer leur sens logique . si les règles sont mélangées , vous pouvez maintenant utiliser votre carte de crédit avant de dépenser votre argent disponible. miser ( x ) : - avoirargent ( x ) , ! ; avoircrédit ( x ) . qui se lit : pour miser x , ou j&apos; ai cet argent d&apos; emblée , ou sinon j&apos; ai le crédit nécessaire . en général , prolog n&apos; impose pas de statut aux paramètres d&apos; un prédicat : ce ne sont pas des paramètres &apos; donnés &apos; ou &apos; résultats &apos; , ou même &apos; donnés / résultats &apos; , leur statut est indifférent a priori et sera défini en fonction des requêtes , et parfois des prédéfinis utilisés . ceci permet souvent la définition de prédicats réversibles : les requêtes fermées , fournissant des résultats à partir des données , pourront être inversés en requêtes ouvertes , cherchant les données menant à un résultat positif. age ( capitaine , 45 ) est vrai ou faux ; age ( capitaine , x ) demande quel est l&apos; âge x du capitaine , age ( x , 45 ) demande quel x a 45 ans . cette possibilité est utilisée dans le générateur / accepteur ci-dessus . prenons des arbres binaires avec comme nœud f et comme feuille 0 ou 1. symetrique ( 0,0 ) . symetrique ( 1,1 ) . symetrique ( f ( a , b ) , f ( y , x ) ) : -symetrique ( a , x ) , symetrique ( b , y ) . ? - symetrique ( f ( f ( 0,1 ) , 1 ) , r ) . ? - symetrique ( a , f ( f ( 0,1 ) , 1 ) ) . le non-déterminisme , pour la résolution de problèmes ouverts : le &apos; ou &apos; utilisé en prolog est un vrai &apos; ou &apos; logique qui permet l&apos; exploration de l&apos; ensemble des possibles. la gestion des requêtes sous-contraintes / sur-contraintes : l&apos; absence de statut pour les paramètres d&apos; un prédicat ( cf. réversibilité ) et le modèle d&apos; exécution employé permet , d&apos; un côté , l&apos; emploi de requêtes sous-contraintes exposant l&apos; ensemble des possibles , et de l&apos; autre côté , l&apos; emploi de requêtes sur-contraintes permettant la vérification de propriétés particulières sur les solutions exhibées ou le filtrage de ces solutions . dès le départ , prolog s&apos; est adressé au domaine des bases de données relationnelles , auquel il apporte une grande souplesse en matière de requêtes , dès lors qu&apos; elles sont déductibles des faits : elles deviennent ainsi des base de données déductives . ainsi , une base de faits du style famille ( père , mère , listedesenfants ) pourra , moyennant quelques règles , répondre à diverses questions de généalogie . au-delà , prolog peut également proposer un système de requêtes commun à un ensemble de bases données interdépendantes ; en combinant les relations de base disponibles , on obtient les services d&apos; une base virtuelle combinant ces bases , d&apos; où un enrichissement considérable des requêtes possibles . des traitements linguistiques sont possibles en prolog sur la base de grammaires formelles. gn ( art ( le , def , masc , sing ) , adj ( beau , masc , sing ) , nom ( chat , masc , sing , animé ) ) . au-delà , un traducteur supposera la transformation de l&apos; arbre abstraction-de-l&apos; entrée en arbre abstraction-de-la-sortie , qui pilotera le générateur du texte final. writeln ( &apos; --------- &apos; ) . suite = &#91; c &#93; , complement ( c ) ) . sujet ( s ) : - est1 ( s , pronom ) ; est1 ( s , nom ) . verbe ( v ) : - est1 ( v , present ) . complement ( c ) : - est1 ( c , nom ) ; est1 ( c , adverbe ) . est1 ( mot , cat ) : - dico ( cat , l ) , dans ( mot , l ) . dico ( nom , &#91; andre , marie , pierre , sylvie &#93; ) . dico ( pronom , &#91; il , elle , on &#93; ) . dico ( present , &#91; aime , chante , charme , ennuie , observe &#93; ) . dico ( adverbe , &#91; bien , fort , mal , peu &#93; ) . 1 ? - phrase ( &#91; pierre , aime , sylvie &#93; ) . 2 ? - phrase ( &#91; elle , chante &#93; ) . 3 ? - phrase ( &#91; on , danse &#93; ) . 4 ? - phrase ( &#91; il , x &#93; ) . 5 ? - gen ( &#91; il , x &#93; ) . analyse ( &#91; s , v &#93; , ph ( as , av ) ) : - sujet ( s , as ) , verbe ( v , av ) . verbe ( v , av ) , complement ( c , ac ) . sujet ( s , sujet ( pronom , s ) ) : - est1 ( s , pronom ) . sujet ( s , sujet ( nom , s ) ) : - est1 ( s , nom ) . sujet ( s , sujet ( &apos; ? ? ? &apos; , s ) ) . verbe ( v , verbe ( present , v ) ) : - est1 ( v , present ) . verbe ( v , verbe ( &apos; ? ? ? &apos; , v ) ) . complement ( c , comp ( nom , c ) ) : - est1 ( c , nom ) . complement ( c , comp ( adv , c ) ) : - est1 ( c , adverbe ) . complement ( c , comp ( &apos; ? ? ? &apos; , c ) ) . 1 ? - analyse ( &#91; sylvie , chante &#93; , a ) . a = ph ( sujet ( nom , sylvie ) , verbe ( present , chante ) ) . 2 ? - analyse ( &#91; pierre , aime , sylvie &#93; , a ) . a = ph ( sujet ( nom , pierre ) , gv ( verbe ( present , aime ) , comp ( nom , sylvie ) ) ) . 3 ? - analyse ( &#91; tu , bois &#93; , a ) . a = ph ( sujet ( ? ? ? , tu ) , verbe ( ? ? ? , bois ) ) . 4 ? - analyse ( &#91; il , chante , faux &#93; , a ) . a = ph ( sujet ( pronom , il ) , gv ( verbe ( present , chante ) , comp ( ? ? ? , faux ) ) ) . où les &apos; ? ? ? &apos; dénotent les erreurs ou les limites du programme . les applications linguistiques de prolog ont été simplifiées et amplifiées par l&apos; emploi des dcg ( definite clause grammar ( en ) catégorie : article contenant un appel à traduction en anglais ) ( pereira &amp; warren , 1980 ) . on peut de là utiliser prolog en vue de la traduction automatique ou semi-automatique . plus fréquemment , un analyseur simple permettra l&apos; emploi de requêtes pseudo-naturelles pour l&apos; interrogation des bases de données relationnelles . des applications prolog a priori intéressantes pouvaient avoir des temps d&apos; exécution excessifs du fait de la combinatoire sous-jacente . prolog et la programmation logique ont donné naissance à un courant de programmation combinant la plupart des spécificités de prolog et les apports de la programmation par contraintes pour aboutir avec prolog iv ( 1996 ) à la programmation logique sous contraintes ( plc ) .cette approche est très efficace dans les problèmes combinatoires , notamment en cao , en recherche opérationnelle et dans les jeux . en effet , on peut par exemple imposer que n variables partageant un domaine à n valeurs s&apos; excluent mutuellement , ramenant le nombre de cas de n ^ n à n ! . par exemple , pour n = 10 , de 10 milliards à 3,6 millions. musiciengrec ( x ) : - musicien ( x ) , grec ( x ) . dès que prolog trouve un musicien , il peut vérifier s&apos; il est grec , auquel cas il s&apos; agit d&apos; une première réponse . de ce fait , la vérification de la nationalité d&apos; un musicien peut se faire pendant que se poursuit la recherche des autres musiciens connus du système . ce procédé est d&apos; autant plus efficace que la recherche commence par le prédicat le plus sélectif : c&apos; est le cas si le système connait moins de musiciens que de grecs . prolog permet le raisonnement par récurrence , et fournit ainsi la possibilité de vérifier des conjectures . sa capacité à traiter des arbres pouvant représenter des formules permet de l&apos; employer en calcul formel . au-delà d&apos; applications purement prolog , la possibilité de combiner prolog à des langages traditionnels a permis dès les années 85 de doter de nombreuses applications de modules intelligents tels que des modules experts . à performances comparables , ces modules augmentent ainsi souplesse et pertinence des applications . prolog travaille dans le cadre de la logique d&apos; ordre 1 et la bonne fin des programmes prolog est garantie dans un cadre de logique monotone , qui suppose qu&apos; il n&apos; y pas mise à jour de la base de connaissances durant un raisonnement . cependant des résultats intermédiaires réutilisables peuvent être mémorisés à l&apos; aide du prédicat assert ( ) , correspondant à une forme irréversible d&apos; apprentissage , par exemple en mémoïsation . au-delà , l&apos; emploi de prédicats retract ( ) permet la modification de la base de connaissances , exigé par le traitement des systèmes dynamiques , comme par certains désapprentissages nécessaires , mais prolog travaille alors en logique non monotone , en perdant la garantie de bonne fin . ces questions ont amené une distinction entre faits statiques , inmodifiables , et faits dynamiques . des extensions ont été proposées , notamment dans le prolog iso , pour favoriser la programmation sous contraintes , la réification permettant un accès limité à l&apos; ordre 2 . prolog est également le support d&apos; extensions dans le domaine de la logique non classique , et en particulier de la logique modale , avec le langage molog développé par l&apos; équipe de luis fariñas del cerro à l&apos; irit . swi prolog , développé par l&apos; université d&apos; amsterdam , libre ( gpl ) template : en manuel swi-prolog . . squeak prolog un prolog intégré à smalltalk dans l&apos; environnement squeak , issu du prolog intégré à smalltalk / v. syntaxe non standard mais permet de mêler programmation objet impérative ( smalltalk ) et logique ( prolog ) . smalltalk peut poser des questions à prolog et prolog peut exécuter des ordres smalltalk . gratuit . w.f. clocksin , c.s. mellish , c. s. , programming in prolog . springer-verlag 1981 . ( isbn 3-540-11046-1 ) : définition du prolog &quot; d&apos; édimbourg &quot; ; plusieurs rééditions . jean-paul delahaye , cours de prolog avec turbo prolog , eyrolles , 1988 - id : 9782212081916 . jacky legrand , le langage prolog - exemples en turbo prolog , technip , 1992 - ( isbn 2-7108-0627-4 ) . patrick blackburn , johan bos , kristina streignitz , prolog tout de suite , college publications , 7 août 2007 .
