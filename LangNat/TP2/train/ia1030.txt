en théorie des graphes , l&apos; algorithme de dijkstra ( prononcé &#91; dɛj.kstra &#93; ) sert à résoudre le problème du plus court chemin . il permet , par exemple , de déterminer un plus court chemin pour se rendre d&apos; une ville à une autre connaissant le réseau routier d&apos; une région . plus précisément , il calcule des plus courts chemins à partir d&apos; une source dans un graphe orienté pondéré par des réels positifs . on peut aussi l&apos; utiliser pour calculer un plus court chemin entre une source et un sommet d&apos; arrivée . l&apos; algorithme porte le nom de son inventeur , l&apos; informaticien néerlandais edsger dijkstra , et a été publié en 1959template : fr principes de l&apos; algorithme de dijkstra , site nimbustier.net. . cet algorithme est de complexité polynomiale . l&apos; algorithme prend en entrée un graphe orienté pondéré par des réels positifs et un sommet source . il s&apos; agit de construire progressivement un sous-graphe dans lequel sont classés les différents sommets par ordre croissant de leur distance minimale au sommet de départ . la distance correspond à la somme des poids des arcs empruntés . au départ , on considère que les distances de chaque sommet au sommet de départ sont infinies sauf pour le sommet de départ pour lequel la distance est de 0 . le sous-graphe de départ est l&apos; ensemble vide . au cours de chaque itération , on choisit en dehors du sous-graphe un sommet de distance minimale et on l&apos; ajoute au sous-graphe . ensuite , on met à jour les distances des sommets voisins de celui ajouté . la mise à jour s&apos; opère comme suit : la nouvelle distance du sommet voisin est le minimum entre la distance existante et celle obtenue en ajoutant le poids de l&apos; arc entre sommet voisin et sommet ajouté à la distance du sommet ajouté . on continue ainsi jusqu&apos; à épuisement des sommets ( ou jusqu&apos; à sélection du sommet d&apos; arrivée ) . l&apos; algorithme de dijkstra fonctionne aussi sur un graphe non orienté ( qui peut le plus peut le moins ) . l&apos; exemple suivant montre les étapes successives dans la résolution du chemin le plus court dans un graphe . les nœuds symbolisent des villes identifiées par une lettre et les arêtes indiquent la distance entre ces villes . on cherche à déterminer le plus court trajet pour aller de la ville a à la ville j. on connaît ainsi le chemin le plus court menant de a à j , il passe par c et h et mesure 487 km . on peut aussi résumer l&apos; exécution de l&apos; algorithme de dijkstra avec un tableau . chaque étape correspond à une ligne . une ligne donne les distances courantes des sommets depuis le sommet de départ . une colonne donne l&apos; évolution des distances d&apos; un sommet donné depuis le sommet de départ au cours de l&apos; algorithme . la distance d&apos; un sommet choisi ( car minimale ) est soulignée . les distances mises à jour sont barrées si elles sont supérieures à des distances déjà calculées . le tableau donne non seulement la distance minimale de la ville a à la ville j ( 487 ) mais aussi le chemin à suivre à rebours ( j - h - c - a ) pour aller de a à j ainsi que toutes les distances minimales de la ville a aux autres villes rangées par ordre croissant. on définit la fonction poids définie sur s \ times s dans \ mathbb { r } ^ + qui à un couple ( s _ 1 , s _ 2 ) associe le poids positif poids ( s _ 1 , s _ 2 ) de l&apos; arc reliant s _ 1 à s _ 2 ( et + \ infty si s&apos; il n&apos; y a pas d&apos; arc reliant s _ 1 à s _ 2 ) . le poids du chemin entre deux sommets est la somme des poids des arcs qui le composent . pour une paire donnée de sommets s _ { deb } ( le sommet du départ ) s _ { fin } ( sommet d&apos; arrivée ) appartenant à s , l&apos; algorithme trouve un chemin depuis s _ { deb } vers s _ { fin } de moindre poids ( autrement dit un chemin le plus léger ou encore le plus court ) . 2. en choisissant l&apos; arc a _ j = ( s _ { j1 } , s _ { j2 } ) dans p \ times g qui donne la distance minimum depuis s _ { deb } à s _ { j2 } en passant tous les chemins créés menant à ce nœud . l&apos; algorithme se termine soit quand p devient un arbre couvrant de g , soit quand tous les nœuds d&apos; intérêtpar exemple , les nœuds n&apos; ayant pas d&apos; arêtes autres que celle que l&apos; on a parcourue pour arriver à eux , ne sont pas considérés comme des nœuds d&apos; intérêt. sont dans p. l&apos; algorithme utilise les fonctions annexes suivantes . 2 faire d &#91; s &#93; : = infini / * on initialise les sommets autres que sdeb à infini * / la suite de caractères / * ... * / est un commentaire . on recherche un nœud de distance minimale ( relié par l&apos; arc de poids le plus faible ) de s _ { deb } parmi les nœuds situés hors de p. le complémentaire de p est noté q. on implémente pour cela une fonction trouve _ min ( q ) qui choisit un nœud de q de distance minimale . il est possible de spécialiser l&apos; algorithme en arrêtant la recherche lorsque l&apos; égalité s _ 1 = s _ { fin } est vérifiée , dans lequel où on ne cherche que la distance minimale entre s _ { deb } et s _ { fin } . l&apos; algorithme de dijkstra est une spécialisation du parcours en largeur . la spécialisation de l&apos; algorithme de dijkstra qui calcule un plus court chemin d&apos; une source à une destination est une instance de l&apos; algorithme a * dans lequel la fonction heuristique est la fonction nulle . l&apos; algorithme a * qui utiliserait une heuristique minorante et monotone ( par exemple la distance à vol d&apos; oiseau ) peut être plus efficace &#91; réf. nécessaire &#93; catégorie : article à référence nécessaire . l&apos; algorithme ne s&apos; applique pas aux graphes avec des poids négatifs . mais l&apos; algorithme de bellman-ford permet de résoudre le problème des plus courts chemins depuis une source avec des poids négatifs ( mais sans cycle négatif ) . l&apos; algorithme de floyd-warshall calcule des plus courts chemins entre tous les sommets dans un graphe où les poids peuvent être négatifs . ( en ) « a short introduction to the art of programming » de edsger w. dijkstra , 1971 , contenant l&apos; article original ( 1959 ) décrivant l&apos; algorithme de dijkstra ( pages 67 à 73 ) . ( en ) thomas h. cormen , charles e. leiserson , ronald l. rivest et clifford stein , introduction à l&apos; algorithmique , mit press et mcgraw-hill , &lt; time &gt; 2001 &lt; / time &gt; , 2e éd. &#91; détail de l ’ édition &#93; , section 24.3 , « dijkstra&apos; s algorithm » , pages 595 – 601 .
