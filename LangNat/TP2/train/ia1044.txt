l&apos; algorithme de parcours en profondeur ( ou dfs , pour depth first search ) est un algorithme de parcours d&apos; arbre , et plus généralement de parcours de graphe , qui se décrit naturellement de manière récursive . son application la plus simple consiste à déterminer s&apos; il existe un chemin d&apos; un sommet à un autre . trémaux et tarry ont , chacun de leur côté , formulé des algorithmes de parcours en profondeur dès le xixe siècle . « le problème des labyrinthes » , nouvelles annales de mathématiques , journal des candidats aux écoles polytechnique et normale , sér . 3 , 14 , 1895 , p. 187-190 &#91; 3 &#93; . . c&apos; est un algorithme de recherche qui progresse à partir d&apos; un sommet s en s&apos; appelant récursivement pour chaque sommet voisin de s. le nom d&apos; algorithme en profondeur est dû au fait que , contrairement à l&apos; algorithme de parcours en largeur , il explore en fait « à fond » les chemins un par un : pour chaque sommet , il marque le sommet actuel , et il prend le premier sommet voisin jusqu&apos; à ce qu&apos; un sommet n&apos; ait plus de voisins ( ou que tous ses voisins soient marqués ) , et revient alors au sommet père . si g n&apos; était pas un arbre , l&apos; algorithme pourrait tourner indéfiniment , c&apos; est pour cela que l&apos; on doit en outre marquer chaque sommet déjà parcouru , et ne parcourir que les sommets non encore marqués . dans le cas d&apos; un arbre , le parcours en profondeur est utilisé pour caractériser l&apos; arbre . enfin , on notera qu&apos; il est tout à fait possible de l&apos; implémenter itérativement à l&apos; aide d&apos; une pile lifo contenant les sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés . durant l&apos; exploration , on marque les sommets afin d&apos; éviter de re-parcourir des sommets parcourus . initialement , aucun sommet n&apos; est marqué . l&apos; algorithme dfs commence au sommet a , nous conviendrons que les sommets à gauche sur ce graphe seront choisis avant ceux de droite . si l&apos; algorithme utilise effectivement un marquage des sommets pour éviter de tourner indéfiniment en boucle , on aura alors l&apos; ordre de visite suivant : a , b , d , f , e , c , g. supposons maintenant que nous n&apos; utilisions pas la méthode de marquage , on aurait alors la visite des sommets suivants dans l&apos; ordre : a , b , d , f , e , a , b , d , f , e , etc indéfiniment , puisque l&apos; algorithme ne peut sortir de la boucle a , b , d , f , e et n&apos; atteindra donc jamais c ou g. comme les autres algorithmes de parcours de graphe , l&apos; algorithme de parcours en profondeur trouve l&apos; ensemble des sommets accessibles depuis un sommet donné s , c&apos; est-à-dire ceux vers lesquels il existe un chemin partant de s. il s&apos; agit précisément des sommets marqués par l&apos; algorithme . ceci s&apos; applique à un graphe orienté ou non orienté . sur un graphe non orienté , on peut utiliser cette propriété pour le calcul des composantes connexes . dans le cas d&apos; un graphe orienté acyclique , le parcours en profondeur peut servir à calculer un tri topologique des sommets . l&apos; algorithme de kosaraju effectue un double parcours en profondeur pour calculer les composantes fortement connexes d&apos; un graphe orienté quelconque .
