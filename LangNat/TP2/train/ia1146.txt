si vous disposez d&apos; ouvrages ou d&apos; articles de référence ou si vous connaissez des sites web de qualité traitant du thème abordé ici , merci de compléter l&apos; article en donnant les références utiles à sa vérifiabilité et en les liant à la section « notes et références » ( modifier l&apos; article , comment ajouter mes sources ? ) . le chaînage arrière ou raisonnement arrière est une méthode d&apos; inférence qui peut être décrite ( en termes profanes ) comme une manière de travailler en remontant en arrière de l&apos; objectif . il est utilisé en intelligence artificielle , dans un système expert à base de règles ou encore dans un assistant de preuve . en théorie des jeux , son utilisation dans les sous-jeux pour trouver une solution au jeu est appelée raisonnement rétrograde . aux échecs , elle est appelée analyse rétrograde et sert à déterminer quels coups ont été joués pour atteindre une position donnée , pour la fin de la partie d&apos; échecs pour les programmes d&apos; échecs . le chaînage arrière est mis en œuvre dans la programmation logique par la sld-résolution . les deux règles sont basées sur le modus ponens , qui est une des deux méthodes les plus couramment utilisées de raisonnement avec des règles d&apos; inférence et les implications logiques — l&apos; autre est le chaînage avant . les systèmes arrières emploient généralement un enchaînement en profondeur , comme prologtemplate : ouvrage . le chaînage arrière commence par une liste d&apos; objectifs ou d&apos; hypothèses et fonctionne à l&apos; envers , de la conséquence à l&apos; antécédent , pour voir s&apos; il y a des données disponibles qui soutiennent l&apos; une de ces conséquencestemplate : harvsp . un moteur d&apos; inférence , à l&apos; aide du chaînage arrière , pourrait chercher l&apos; inférence des règles jusqu&apos; à ce qu&apos; il trouve celui qui a une conséquence qui correspond à un objectif désiré . si l&apos; antécédent de cette règle n&apos; est pas connu pour être vrai , alors il est ajouté à la liste des objectifs . si x coasse et mange des mouches , alors x est une grenouille . si x piaule et chante , alors x est un canari . si x est une grenouille , alors x est vert . si x est un canari , alors x est jaune . sur ces règles de bases examinées , les troisième et quatrième règles seraient choisies , parce que leurs conséquents ( alors x est vert , alors x est jaune ) correspondent à l&apos; objectif ( déterminer la couleur de fritz ) . on ne sait pas encore que fritz est une grenouille , donc les antécédents ( si x est une grenouille , si x est un canari ) sont ajoutés à la liste d&apos; objectifs . les règles de base sont de nouveau examinées , et cette fois-ci ce sont les deux premières règles qui sont sélectionnées , parce que leurs conséquents ( alors x est une grenouille , alors x est un canari ) correspondent aux nouveaux objectifs qui viennent d&apos; être ajoutés à la liste . l&apos; antécédent ( si x coasse et mange des mouches ) est connu pour être vrai et , par conséquent , on peut conclure que fritz est une grenouille , et non un canari . l&apos; objectif de détermination de la couleur de fritz est maintenant atteint ( fritz est vert s&apos; il s&apos; agit d&apos; une grenouille , et jaune s&apos; il est un canari , mais il s&apos; agit d&apos; une grenouille car il coasse et mange les mouches et , par conséquent , fritz est vert ) . les objectifs correspondent toujours aux versions affirmées des conséquents de conséquences ( et non les versions négatives comme dans un modus tollens ) et leurs antécédents sont alors considérés comme les nouveaux objectifs ( et non les conclusions comme dans l&apos; affirmation du conséquent ) qui en fin de compte doivent correspondre à des faits connus , généralement définis comme des conséquents dont les antécédents sont toujours vrais . ainsi , la règle d&apos; inférence utilisée est le modus ponens . cette méthode est appelée « goal-driven » ( retranscrit littéralement guidée par un objectif ) , parce que la liste des objectifs détermine les règles qui sont choisies et utilisées , contrairement au chaînage avant . les langages de programmation tels que prolog , knowledge machine et eclipse soutiennent le chaînage arrière au sein des moteurs d&apos; inférencetemplate : harvsp . ( en ) cet article est partiellement ou en totalité issu de l ’ article de wikipédia en anglais intitulé « backward _ chaining » ( voir la liste des auteurs ) .
