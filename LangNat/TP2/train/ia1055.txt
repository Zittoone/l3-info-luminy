en informatique , un algorithme glouton ( greedy algorithm en anglais , parfois appelé aussi algorithme gourmand ) est un algorithme qui suit le principe de faire , étape par étape , un choix optimum local . dans certains cas cette approche permet d&apos; arriver à un optimum global , mais dans le cas général c&apos; est une heuristique . l&apos; illustration ci-contre montre un cas où ce principe est mis en échec . en algorithmique , et plus précisément en optimisation combinatoire , de nombreux algorithmes fonctionnent en faisant une série d&apos; étapes , avec des choix . une méthode classique est la programmation dynamique qui permet de tester tous les choix . cependant les complexités des algorithmes de ce type sont parfois trop grandes et l&apos; on choisit d&apos; autres méthodes . l&apos; une de ces méthodes est de choisir localement la meilleure solution : ce sont les algorithmes gloutonstemplate : cormen2fr chap. 16 « algorithmes gloutons » , template : p. . . article détaillé : problème du rendu de monnaie . suivant le système de pièces , l&apos; algorithme glouton est optimal ou pas . dans le système de pièces européen ( en centimes : 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ) , où l&apos; algorithme glouton donne la somme suivante pour 37 : 20 + 10 + 5 + 2 , on peut montrer que l&apos; algorithme glouton donne toujours une solution optimale . dans le système de pièces ( 1 , 3 , 4 ) , l&apos; algorithme glouton n&apos; est pas optimal , comme le montre l&apos; exemple simple suivant . il donne pour 6 : 4 + 1 + 1 , alors que 3 + 3 est optimal . article détaillé : arbre couvrant de poids minimal . le problème consiste , dans un graphe non orienté connexe et valué , à trouver un sous-ensemble d&apos; arêtes , formant un arbre , incluant tous les sommets ( c&apos; est-à-dire un arbre couvrant ) , tel que la somme des poids de chaque arête soit minimale ( d&apos; où le terme arbre couvrant de poids minimal ) . l&apos; algorithme de prim et l&apos; algorithme de kruskal sont deux des algorithmes gloutons pour le problèmetemplate : cormen2en , chap. 23 : minimum spanning trees , template : p. . dans l&apos; algorithme de prim , on choisit un sommet et l&apos; on fait grandir l&apos; arbre depuis ce sommet de façon gloutonne . plus précisément , on choisit un sommet arbitraire puis l&apos; on sélectionne l&apos; arête incidente à ce sommet de poids minimal et on l&apos; ajoute à l&apos; arbre et ainsi de suite . autrement dit on construit l&apos; arbre de manière itérative , on sélectionnant à chaque pas l&apos; arête de poids minimum qui relie un sommet de l&apos; arbre avec un sommet en dehors de l&apos; arbre . l&apos; algorithme de kruskal consiste à faire croître une forêt jusqu&apos; à couverture complète . chaque augmentation se fait de la manière la plus économique possible . cet exemple montre qu&apos; il existe parfois plusieurs algorithmes gloutons pour un même problème . le problème de coloration consiste à donner des couleurs aux sommets tel que pour chaque arête , les deux sommets reliés soient de couleurs différentes . l&apos; ensemble de couleur est limité . le problème est np-complet . l&apos; algorithme glouton suivant , parfois appelé first-fit algorithmtemplate : chapitre est une heuristique pour ce problème . pour un graphe il existe toujours un ordre des sommets qui mène à une bonne solution en utilisant cet algorithme , cependant pour d&apos; autres ordres l&apos; algorithme sera bloqué car toutes les couleurs disponibles auront déjà été utilisées , et l&apos; étape la première couleur de c non utilisée par les voisins de v ne pourra pas être effectuée . les algorithmes gloutons sont reliés au concept de matroïde , dans le sens où , informellement , tout problème algorithmique qui peut être représenté par un matroïde peut être résolu par un algorithme gloutontemplate : lien web . . une notion proche est celle de greedioide ( en ) catégorie : article contenant un appel à traduction en anglais . un algorithme glouton peut être dans certains cas un algorithme d&apos; approximation , c&apos; est par exemple le cas pour le problème du k-centre .
