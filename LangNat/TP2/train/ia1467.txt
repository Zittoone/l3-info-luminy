en informatique théorique , le problème sat ou problème de satisfaisabilité booléenne est le problème de décision , qui , étant donné une formule de logique propositionnelle , détermine s&apos; il existe une assignation des variables propositionnelles qui rend la formule vraie . ce problème est très important en théorie de la complexité . il a été mis en lumière par le théorème de cooktemplate : article , template : article , qui est à la base de la théorie de la np-complétude et du problème p = np . le problème sat a aussi de nombreuses applications notamment en satisfaction de contraintes , planification classique , model checking , diagnostic , et jusqu&apos; au configurateur d&apos; un pc ou de son système d&apos; exploitation &#91; réf. nécessaire &#93; catégorie : article à référence nécessaire : on se ramène à des formules propositionnelles et on utilise un solveur sat . la formule ( p \ land \ lnot p ) n&apos; est pas satisfaisable car aucune valeur de p ne peut rendre la formule vraie . article détaillé : forme normale conjonctive . un littéral \ ell est une variable propositionnelle v _ j ( littéral positif ) ou la négation d&apos; une variable propositionnelle \ lnot v _ j ( littéral négatif ) . une clause est une disjonction de la forme \ overset n { \ underset { i = 1 } { \ bigvee } } \ ell _ i = ( \ ell _ 1 \ lor \ ell _ 2 \ lor \ ldots \ lor \ ell _ n ) où les \ ell _ i sont des littéraux . une formule du calcul propositionnel est en forme normale conjonctive ( ou forme clausale ou cnf sigle de l&apos; anglais conjunctive normal form ) si elle est une conjonction de clauses . soit l&apos; ensemble de variables \ { v _ 1 , v _ 2 , v _ 3 \ } \ et la formule f = ( v _ 1 \ lor v _ 2 ) \ land ( \ neg v _ 1 \ lor v _ 3 ) \ land ( \ neg v _ 2 \ lor \ neg v _ 1 ) . f \ est satisfaisable puisque , si on pose v _ 1 = \ mathit { vrai } , \ v _ 2 = \ mathit { faux } , \ v _ 3 = \ mathit { vrai } , alors f \ est logiquement vrai . en revanche , f &apos; = ( v _ 1 \ lor v _ 2 ) \ land ( \ neg v _ 1 \ lor v _ 3 ) \ land ( \ neg v _ 2 \ lor v _ 1 ) \ land ( \ neg v _ 2 \ lor v _ 3 ) \ land ( \ neg v _ 1 \ lor \ neg v _ 3 ) n&apos; est pas satisfaisable , car f &apos; \ sera évaluée comme faux quelles que soient les valeurs attribuées à v _ 1 , v _ 2 \ text { et } v _ 3 . si la formule propositionnelle n&apos; est pas sous forme normale conjonctive , on peut la transformer en une forme normale conjonctive équivalente de taille au plus exponentielle en la formule initiale . on peut aussi la transformer en une forme normale conjonctive équisatisfiable de taille linéaire en la formule initiale . on considère des restrictions syntaxiques du problème sat . le problème cnf-sat est la restriction du problème sat aux formes normales conjonctives . le problème 2-sat est la restriction du problème sat aux formes normales conjonctives avec au plus 2 littéraux par clause . le problème 3-sat est la restriction du problème sat aux formes normales conjonctives avec au plus 3 littéraux par clause . exemple d&apos; instance : ( v _ 1 \ lor \ neg v _ 2 \ lor v _ 3 ) \ land ( \ neg v _ 1 \ lor v _ 3 \ lor v _ 4 ) . le problème horn-sat est la restriction du problème sat aux formes normales conjonctives où les clauses sont des clauses de horn . le problème sat est un problème np – complet d&apos; après le théorème de cook . en particulier , on ne connaît aucun algorithme déterministe polynomial pour le résoudre . de même , comme toute formule peut se transformer en une forme normale conjonctive équisatisfiable de taille linéaire en la formule initiale , le problème cnf-sat est aussi np-complet . ( \ ell _ { n-2 } \ lor \ lnot u _ { n-4 } \ lor u _ { n-3 } ) \ land ( \ ell _ { n-1 } \ lor \ ell _ { n } \ lor \ lnot u _ { n-3 } ) . le problème 2-sat est la restriction du problème sat aux formes normales conjonctives avec au plus 2 littéraux par clause . ce problème est dans la classe p. sous l&apos; hypothèse p \ neq np , il n&apos; est pas np-complet . il existe plusieurs algorithmes polynomiaux déterministes pour résoudre le problème 2-sat . algorithme de aspvall , plass et tarjan template : en bengt aspvall , michael f. plass , et robert e. tarjan , « a linear-time algorithm for testing the truth of certain quantified boolean formulas » , information processing letters , 8 , p. 121-123 ( 1979 ) , template : lire en ligne . l&apos; algorithme prend une formule \ varphi en forme normale conjonctive avec au plus 2 littéraux par clause . une clause d&apos; ordre deux v _ 1 \ lor v _ 2 est équivalente aux implications \ lnot v _ 1 \ rightarrow v _ 2 et \ lnot v _ 2 \ rightarrow v _ 1 . on ajoute les arcs ( \ lnot v _ 1 , v _ 2 ) et ( \ lnot v _ 2 , v _ 1 ) pour chaque clause v _ 1 \ lor v _ 2 . la formule \ varphi est satisfaisable si et seulement si pour toute variable propositionnelle v _ i ~ de \ varphi , v _ i ~ et \ lnot v _ i sont dans deux composantes fortement connexes distinctes dans graphe 2-sat . on utilise alors l&apos; algorithme de tarjan ( ou l&apos; algorithme de kosaraju ) pour calculer les composantes fortement connexes du graphe 2-sat . christos papadimitriou a montré , en 1994 , que le problème 2-sat est nl-complet . le problème de satisfiabilité d&apos; un ensemble de clauses de horn propositionnelles est dans la classe p. plus précisément , il existe un algorithme linéairetemplate : article en la taille des clauses qui résout le problème de satisfiabilité . plus précisément , il est p-complet &#91; réf. nécessaire &#93; catégorie : article à référence nécessaire . la plus évidente des méthodes pour résoudre un problème sat est de parcourir la table de vérité du problème , mais la complexité est alors exponentielle par rapport au nombre de variables . pour prouver la satisfaisabilité du cnf \ phi \ , il suffit de choisir une variable v ~ et de prouver récursivement la satisfaisabilité de v \ land \ phi ou \ neg v \ land \ phi . la procédure est plus facile récursivement puisque a \ land \ phi avec a = v \ ou a = \ neg v peut souvent se simplifier . l&apos; appel récursif construit ainsi un arbre binaire de recherche . généralement , il existe à chaque nœud des clauses unitaires ( la cnf est de la forme \ phi = a \ land \ phi &apos; ) , qui permettent de réduire fortement l&apos; espace de recherche . ( v _ 1 \ lor \ neg v _ 2 ) \ land \ neg v _ 3 \ land ( v _ 3 \ lor \ neg v _ 1 ) . ( v _ 1 \ lor \ neg v _ 2 ) \ land \ neg \ textit { faux } \ land ( \ textit { faux } \ lor \ neg v _ 1 ) = ( v _ 1 \ lor \ neg v _ 2 ) \ land \ neg v _ 1 . à nouveau , on a une clause unitaire , et on obtient v _ 1 = \ textit { faux } ~ . puis , par propagation , on obtient v _ 2 = \ textit { faux } ~ . dans cet exemple , on a trouvé les valeurs des trois variables sans même développer l&apos; arbre de recherche . de manière générale , on peut réduire fortement l&apos; espace de recherche . d&apos; autre part , si une variable v \ apparaît toujours positivement dans la cnf \ phi \ , alors on peut poser v = \ textit { vrai } \ puisque \ phi \ est satisfaisable si et seulement si \ phi \ land v est satisfaisable ( et de même si la variable apparaît négativement ) . ainsi , dans l&apos; exemple précédent , v _ 2 \ n&apos; apparaît que négativement et l&apos; assignation v _ 2 = faux \ peut être effectuée . remarquons que cette affectation permet d&apos; accélérer la découverte d&apos; une solution mais que des solutions pourraient exister en effectuant l&apos; assignation contraire . l&apos; algorithme dpll ( davis , putnamtemplate : en martin davis et hillary putnam , « a computing procedure for quantification theory » , communications of the acm , 7 , p. 201-215 ( 1960 ) template : lire en ligne , davis , logemann , lovelandtemplate : en martin davis , george logemann et donald loveland , « a machine program for theorem proving » , communications of the acm , 5 , p. 394-397 ( 1962 ) , template : lire en ligne ) se base sur ces idées . le choix de la variable v \ à développer est très important pour les performances des algorithmes sat . on choisit généralement les variables qui apparaissent le plus souvent , si possible dans des clauses de taille 2 . il existe différentes méthodes pour générer de nouvelles clauses à partir d&apos; une inconsistance locale. et l&apos; interprétation partielle \ mathcal { i } définie par : x _ 2 = \ textit { faux } , x _ 3 = \ textit { faux } . cette interprétation mène à un conflit car x _ 2 implique que x _ 1 = vrai , tandis que x _ 3 implique que x _ 1 = faux . pour générer une clause représentant ce conflit , il est possible de prendre la négation de l&apos; interprétation \ mathcal { i } : \ neg \ mathcal { i } = \ neg ( \ neg x _ 2 \ land \ neg x _ 3 ) = x _ 2 \ lor x _ 3 . cependant , cette méthode possède un inconvénient majeur : la taille de la clause est entièrement déterminée par toute l&apos; interprétation . or , certaines parties de l&apos; interprétation peuvent être complètement indépendantes du conflit que l&apos; on souhaite représenter . en effet , ajoutons à l&apos; instance \ phi _ 1 les formules : c _ { i } = x _ i \ lor x _ { i + 1 } , 4 \ leq i \ leq n et soit l&apos; interprétation courante \ mathcal { i } = \ { x _ 2 = faux , x _ 3 = faux , x _ { 4 \ leq i \ leq n } = faux \ } . le conflit provient des deux premières clauses et donc , des valeurs de x _ 2 et x _ 3 . or , la clause générée par la négation de l&apos; interprétation prendra en compte toutes les variables à l&apos; exception de x _ 1 . de ce fait , la clause sera inutilement longue . \ mathcal { r } _ 4 &amp; = &amp; \ mathcal { r } _ 3 \ vdash _ \ mathcal { r } c _ 4 &amp; = &amp; \ neg h \ lor \ neg g. une fois la clause apprise , celle-ci sera utilisée pour le retour en arrière . l&apos; idée derrière le retour en arrière non chronologique est qu&apos; un retour en arrière sera effectué de manière à ce que l&apos; état des assignations soit tel qu&apos; il ne reste qu&apos; un seul littéral non assigné . ainsi , grâce à la clause apprise , il sera possible de continuer les différentes propagations alors que cela n&apos; était plus possible sans elle . bien que dans cet exemple le retour en arrière ne s&apos; effectue que sur un seul niveau , il est possible que celui-ci monte de plusieurs niveau d&apos; un coup . en effet , imaginons que nous puissions ajouter n niveaux entre le niveau 2 et le niveau 3 où toutes les variables qui y apparaissent soient de nouvelles variables . puisque ces niveaux n&apos; auraient pas d&apos; impact sur l&apos; ancien niveau 3 , le retour en arrière remonterait d&apos; un coup ces n + 1 niveaux . l&apos; approche prospective consiste à prospecter l&apos; arbre de recherche pour découvrir des assignations certaines . ainsi , étant donné un cnf \ phi \ , étant donnée une variable non instanciée v \ , on prospecte les cnfs \ phi \ land v et \ phi \ land \ neg v. si les deux cnfs conduisent à l&apos; instanciation de la même variable v &apos; \ avec la même valeur , alors l&apos; instanciation peut se faire dès la cnf \ phi \ . considérons la cnf \ phi = ( v _ 1 \ lor v _ 2 ) \ land ( v _ 1 \ lor \ neg v _ 2 \ lor v _ 3 ) \ land ( \ neg v _ 1 \ lor v _ 2 \ lor v _ 4 ) \ land ( \ neg v _ 3 \ lor \ neg v _ 4 ) . nous nous intéressons ici à la variable v _ 2 \ et prospectons la variable v _ 1 \ . considérons l&apos; assignation v _ 1 = \ textit { vrai } \ . on obtient ( v _ 2 \ lor v _ 4 ) \ land ( \ neg v _ 3 \ lor \ neg v _ 4 ) et donc l&apos; assignation v _ 2 = \ textit { vrai } \ ( puisque cette variable apparaît uniquement positivement ) . considérons l&apos; assignation v _ 1 = \ textit { faux } \ . on obtient v _ 2 \ land ( \ neg v _ 2 \ lor v _ 3 ) \ land ( \ neg v _ 3 \ lor \ neg v _ 4 ) et donc l&apos; assignation v _ 2 = \ textit { vrai } \ par clause unitaire . dans tous les cas , on obtient v _ 2 = \ textit { vrai } \ et il est donc possible d&apos; effectuer cette assignation dès la cnf \ phi \ . rappelons que la complexité du problème sat vient de la taille exponentielle de l&apos; arbre de recherche par rapport au nombre de variables . la prospection permet de réduire fortement ce nombre de variables dès la racine ( ou à n&apos; importe quel nœud de l&apos; arbre ) avec une complexité supplémentaire relativement faible eu égard à la diminution de l&apos; arbre de recherche . partant d&apos; une assignation de toutes les variables , on cherche à modifier certaines valuations de façon à réduire le nombre de clauses non satisfaites . cet algorithme souffre de plusieurs défauts : il peut tomber dans des minima locaux et il est incapable de prouver la non-satisfaisabilité , mais il s&apos; avère très efficace dans les problèmes non structurés ( c&apos; est-à-dire souvent les problèmes générés aléatoirement ) . en cas d&apos; échec après un temps long , il est possible de choisir une nouvelle assignation aléatoire pour éviter les minima locaux . il est possible de réduire ( traduire ) certains problèmes d&apos; intelligence artificielle au problème sat afin de résoudre efficacement ces problèmes . le diagnostic de systèmes statiques consiste à déterminer si un système a un comportement défectueux étant donnée l&apos; observation des entrées et sorties du système . le modèle du système peut être traduit en un ensemble de contraintes ( disjonctions ) : pour chaque composant c du système , une variable ab ( c ) est créée qui est évaluée à vraie si le composant a un comportement anormal ( abnormal ) . les observations peuvent être également traduites par un ensemble de disjonctions . l&apos; assignation trouvée par l&apos; algorithme de satisfaisabilité est un diagnostic . le problème de planification classique consiste à trouver une séquence d&apos; actions menant d&apos; un état du système à un ensemble d&apos; états . étant donnée une longueur maximale du plan n et un ensemble v de variables d&apos; état booléennes permettant de décrire l&apos; état du système , on crée les variables propositionelles v ^ i pour tout i \ in \ { 0 , \ dots , n \ } et toute variable v \ in v. la variable v _ i est vraie si la variable d&apos; état est vraie après l&apos; action numéro i. on crée également les variables a ^ i pour tout i \ in \ { 1 , \ dots , n \ } et toute action a. la variable a ^ i est vraie si l&apos; action numéro i est a. il est alors possible de transformer le modèle du système en un ensemble de clauses . par exemple , si l&apos; action a fait passer la variable v _ 1 à vrai lorsque celle-ci est fausse , alors la cnf contiendra une clause ( \ neg v ^ 0 ) \ rightarrow a ^ 1 \ rightarrow v ^ 1 ( ce qui est traduit par la clause v ^ 0 \ lor \ neg a ^ 1 \ lor v ^ 1 ) . l&apos; assignation trouvée par l&apos; algorithme de satisfaisabilité peut être immédiatement traduite en plan . la planification classique par sat est très efficace si on connaît la longueur n du plan &#91; réf. nécessaire &#93; catégorie : article à référence nécessaire . si cette valeur n&apos; est pas connue , on peut chercher des plans pour une valeur incrémentale , ce qui est parfois coûteux ( notamment parce que la cnf est non satisfaisable jusqu&apos; à n – 1 ) . une approche semblable a été utilisée pour le model checking ( vérification de propriétés d&apos; un modèle ) . la principale différence est que le model checking s&apos; applique à des trajectoires de longueur infinie contrairement à la planification . cependant , si l&apos; espace d&apos; états du système est fini , toute trajectoire infinie boucle à un certain point et on peut borner la taille des trajectoires qu&apos; il est nécessaire de vérifier . le bounded model checking tire parti de cette propriété pour transformer le problème de model checking en un certain nombre de problèmes de satisfaisabilité . la complexité du problème sat est une composante essentielle de la sécurité de tout système de cryptographie . par exemple , une fonction de hachage sécurisée constitue une boîte noire pouvant être formulée en un temps et un espace fini sous la forme d&apos; une conjonction de clauses normales , dont les variables booléennes correspondent directement aux valeurs possibles des données d ’ entrée de la fonction de hachage , et chacun des bits de résultat devra répondre à un test booléen d&apos; égalité avec les bits de données d ’ un bloc de données d ’ entrées quelconque . les fonctions de hachages sécurisées servent notamment dans des systèmes d&apos; authentification ( connaissance de données secrètes d ’ entrée ayant servi à produire la valeur de hachage ) et de signature ( contre toute altération ou falsification « facile » des données d ’ entrée , qui sont connues en même temps que la fonction de hachage elle-même et de son résultat ) . la sécurité de la fonction de hachage dépend de la possibilité de retrouver un bloc de données d ‘ entrée arbitraire ( éventuellement différent du bloc secret de données pour lequel une valeur de hachage donnée a été obtenue ) permettant d&apos; égaliser la valeur binaire retournée par la fonction de hachage . une méthode d&apos; exploration systématique de toutes les valeurs possibles des données d ‘ entrée et pour lesquelles on applique la fonction de hachage comme un oracle , permet effectivement de satisfaire à la question de une valeur de hachage égale à celle cherchée , mais sa complexité algorithmique sera exponentielle ( en fonction de la taille maximale en bits des données d ’ entrée de la fonction de hachage ) . chercher à égaliser une valeur de hachage avec des variables d&apos; entrée de valeur inconnue constitue un problème sat ( et comme en pratique les données d ’ entrée de la fonction de hachage sont constituées de nombreux bits , ce sera un problème n-sat avec n assez élevé ( et en tout cas supérieur ou égal à 3 ) . on sait alors que ce problème est réductible en temps polynomial à un problème 3 – sat , qui est np-complet . la sécurité de la fonction de hachage sera fortement liée au fait de l&apos; impossibilité de la réduire plus simplement ( que par un algorithme np-complet de complexité suffisante ) en réduisant la forme conjonctive des clauses qui la définissent simplement , pour y isoler des sous-ensembles de variables d ’ entrées de taille plus restreinte , mais suffisante pour déterminer une partie du résultat de la fonction de hachage dont l ’ ordre n sera alors très inférieur , et pour ne plus avoir à explorer que les valeurs possibles de ces seuls sous-ensembles de variables pour satisfaire la condition d&apos; égalité du résultat , sans avoir à tester toutes les autres variables dont la valeur peut être fixée arbitrairement à certaines valeurs déterminées par un algorithme plus simple ( apprentissage de clauses , approches prospectives ci-dessus ) . il existe des extensions au problème sat . max-sat : étant donné un ensemble de clauses , trouver le nombre maximum de clauses que l&apos; on peut satisfaire . satisfiabilité en logique modale , logique du premier ordre , logique du second ordre ... sharad malik et lintao zhang boolean satisfiability : from theoretical hardness to practical success , communications of the acm , ( 2009 ) vol . 52 no . 8 , pages 76-82 .
