pour les articles homonymes , voir bfs . l&apos; algorithme de parcours en largeur ( ou bfs , pour breadth first search en anglais ) permet le parcours d&apos; un graphe ou d&apos; un arbre de la manière suivante : on commence par explorer un nœud source , puis ses successeurs , puis les successeurs non explorés des successeurs , etc. l&apos; algorithme de parcours en largeur permet de calculer les distances de tous les nœuds depuis un nœud source dans un graphe non pondéré ( orienté ou non orienté ) . il peut aussi servir à déterminer si un graphe non orienté est connexe . cet algorithme diffère de l&apos; algorithme de parcours en profondeur par le fait que , à partir d&apos; un nœud source s , il liste d&apos; abord les voisins de s pour ensuite les explorer un par un . ce mode de fonctionnement utilise donc une file dans laquelle il prend le premier sommet et place en dernier ses voisins non encore explorés . les nœuds déjà visités sont marqués afin d&apos; éviter qu&apos; un même nœud soit exploré plusieurs fois . dans le cas particulier d&apos; un arbre , le marquage n&apos; est pas nécessaire . mettre le nœud source dans la file . retirer le nœud du début de la file pour l&apos; examiner . mettre tous les voisins non explorés dans la file ( à la fin ) . si la file n&apos; est pas vide reprendre à l&apos; étape 2 . note : l&apos; utilisation d&apos; une pile au lieu d&apos; une file transforme l&apos; algorithme du parcours en largeur en l&apos; algorithme de parcours en profondeur . il explore dans l&apos; ordre les sommets a , b , c , e , d , f , g , contrairement à l&apos; algorithme de parcours en profondeur qui cherche dans cet ordre : a , b , d , f , c , g , e. l&apos; algorithme s&apos; implémente à l&apos; aide d&apos; une file . soit un graphe g = ( v , e ) , dont aucun sommet n&apos; est marqué à l&apos; appel de l&apos; algorithme . tous les sommets insérés dans la file sont marqués et l&apos; instruction conditionnelle assure donc que les sommets seront insérés au plus une fois , comme l&apos; insertion dans la file se fait en θ ( 1 ) , la complexité est en θ ( v ) . les voisins étant donnés par liste d&apos; adjacence seront visités au plus e fois car la somme des longueurs des listes d&apos; adjacence est e ( le nombre d&apos; arêtes ) . la complexité totale est donc θ ( v + e ) . le parcours en largeur explore tous les sommets accessibles depuis le sommet source . on peut utiliser cet algorithme pour calculer les composantes connexes d&apos; un graphe non orienté avec une complexité linéaire en la taille du graphe . de plus , lors de ce parcours , les sommets sont explorés par distance croissante au sommet source . grâce à cette propriété , on peut utiliser l&apos; algorithme pour résoudre le problème de cheminement suivant : calculer des plus courts chemins entre le sommet source et tous les sommets du graphe . l&apos; algorithme de dijkstra peut être vu comme une généralisation du parcours en largeur avec des arcs pondérés positivement .
