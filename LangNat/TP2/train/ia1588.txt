strips ( ou stanford research institute problem solver ) est un algorithme de planification classique conçu par richard fikes et nils nilsson en 1971 . l&apos; algorithme de strips est assez simple , mais il est intéressant comme exemple pédagogique . on nomme aussi par ce nom le langage de représentation des données utilisée par l&apos; algorithme . avec le general problem solver de newell et simon de 1961 , il fait partie des premiers planificateurs utilisés en intelligence artificielle et été suivi de nombreux dérivés ( graphplan , ipp , stan … ) . l&apos; algorithme de strips fonctionne selon l&apos; analyse des fins et des moyens ( ou mean ends analysis ) énoncée par aristote : on part des buts que l&apos; on veut atteindre et on tente de trouver les moyens qui peuvent y conduire . cela produit de nouveaux buts que l&apos; on tente de résoudre et ainsi de suite jusqu&apos; à ce que l&apos; on tombe sur les hypothèses de départ . le plan est alors obtenu en cheminant sens inverse . en pratique l&apos; algorithme calcule la différence entre les états du monde qu&apos; il considère . il considère des actions capables de réduire ces différences et les combine pour construire le plan . les états possibles du monde , chaque état est un ensemble de prédicats . les actions ( aussi appelées opérateurs ) définies par leurs préconditions et leurs modifications sur l&apos; état du monde . les préconditions sont une conjonction de prédicats . chacun de ces prédicats doit être vérifié au moment où l&apos; on exécute l&apos; action . les modifications peuvent être représentées comme une liste d&apos; ajouts et une liste de suppressions de prédicats . l&apos; algorithme entretient une représentation du monde qui évolue pendant le déroulement de l&apos; algorithme . au cours de ce déroulement , l&apos; algorithme peut décider d&apos; effectuer une action qui modifiera l&apos; état du monde . l&apos; algorithme consiste à stocker dans une pile une suite de buts et d&apos; actions à accomplir . le but initial est positionné en bas de la pile , les sous-buts apparaissent au-dessus , et les sous-sous-buts encore plus haut ... à chaque étape , on traite l&apos; élément en haut de la pile . si le but est vérifié dans le monde courant , il est supprimé , sinon , l&apos; algorithme choisit une action permettant d&apos; obtenir ce but . l&apos; action choisie est empilée , ainsi que les sous-buts à obtenir ( ces sous-buts sont les prédicats contenus dans la précondition de l&apos; action ) . on réitère alors l&apos; algorithme pour traiter ces sous-buts . si plusieurs actions sont utilisables pour satisfaire un but , on choisit l&apos; une d&apos; entre elles , les autres seront essayées si l&apos; algorithme échoue en utilisant la première . ceci nécessite un backtracking ( ou l&apos; utilisation de la récursivité ) . on vérifie que la précondition est vérifiée . si oui , on exécute l&apos; action ( ce qui met à jour le monde ) on dépile l&apos; action et on réitère l&apos; algorithme . sinon , l&apos; algorithme effectue un backtrack jusqu&apos; au dernier choix d&apos; actions ( cela implique qu&apos; il dépile jusqu&apos; à trouver une action pour laquelle il existe une alternative ) . si aucune action alternative n&apos; existe , ou si elles ont toutes été testées , l&apos; algorithme échoue . si le haut de la pile est occupé par une action , c&apos; est que tous les sous-buts issus de la précondition de cette action ont été traités . le traitement d&apos; un sous-but consiste à effectuer des actions qui transforment l&apos; état du monde de manière à ce qu&apos; il satisfasse le sous-but . cependant il est possible que malgré ces traitements , l&apos; état du monde ne satisfasse pas la précondition . en effet , le traitement d&apos; un sous-but peut défaire un sous-but précédemment traité . le problème de strips est la linéarité : cela signifie que les sous-buts sont traités les uns après les autres . cela provoque des situations de blocage dans le cas où la réalisation du premier sous-but engendre une action rendant impossible le second sous-but . « la clé se trouve dans la boîte aux lettres » , noté dansboite ( ) . si le robot est dans le jardin et a pour but : portefermee ( ) \ wedge dansboite ( ) , il a intérêt à s&apos; occuper du sous-but portefermee ( ) avant le sous-but dansboite ( ) sinon il risque de glisser la clé dans la boîte aux lettres sans pouvoir fermer la porte par la suite . la première solution , qui ne résout pas toujours le problème , est d&apos; ordonner les sous-buts a priori et d&apos; une façon intelligente ( cela fonctionne pour l&apos; exemple précédent ) . supposons à présent que les prédicats soient ordonnés ainsi : traiter portefermee ( ) avant dansboite ( ) . si le robot est désormais dans la maison , il fermera la porte puis se trouvera bloqué au moment d&apos; aller mettre la clé dans la boite aux lettres qui a le malheur de se trouver dans le jardin . si on avait inversé les deux buts , on se serait retrouvé dans le cas de blocage expliqué précédemment . la solution à ce problème est la planification non-linéaire . là ou strips force un ordre d&apos; exécution , elle permet d&apos; effectuer les actions et de les ordonner uniquement lorsque c&apos; est nécessaire : on parle d&apos; engagement au plus tard ( least commitment planning ) . fikes , r. e. &amp; n. j. nilsson , strips : a new approach to the application of theorem proving , dans artificial intelligence , vol . 2 , 1971 . elaine rich , intelligence artificielle , 1987 .
