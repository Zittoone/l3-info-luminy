en informatique quantique , l ´ algorithme de grover est un algorithme de recherche , permettant de rechercher un ou plusieurs éléments qui répondent à un critère donné parmi n éléments non classés en temps proportionnel à \ sqrt { n } et avec un espace de stockage proportionnel à \ log ( n ) . il a été découvert par lov grover en 1996grover l.k. : a fast quantum mechanical algorithm for database search , proceedings , 28th annual acm symposium on the theory of computing , ( may 1996 ) p. 212 . dans les mêmes conditions ( recherche parmi des éléments non classés ) , un algorithme classique ne peut faire mieux qu&apos; une recherche dans un temps proportionnel à n , en testant successivement le critère sur chaque élément . l&apos; étendue de la gamme de critères pouvant être utilisée par cet algorithme lui donne un caractère universel , ce qui en fait un des algorithmes les plus importants et potentiellement le plus utile de l&apos; informatique quantique . l&apos; exemple classique d&apos; utilisation de cet algorithme est la recherche , dans un annuaire téléphonique ordinaire classé alphabétiquement , du nom qui correspond à un numéro de téléphone donné . l&apos; algorithme de grover fonctionne toujours en lui présentant les nombres entiers de 1 à n , représentant dans le cas de l&apos; annuaire une position dans ce dernier . le critère de sélection est dans ce cas : la position correspond à un numéro de téléphone donné . la position étant connue , on en déduit le nom ou toute autre information liée à la position . plus généralement , l&apos; ensemble des nombres entiers de 1 à n peut indexer un ensemble de solutions possibles à un problème . dans ce cas , s&apos; il est possible de vérifier rapidement qu&apos; une solution résout un problème ( ce qui est généralement le cas , et ce qui définit même toute une classe importante de problèmes dits de complexité np ) , alors il est possible à l&apos; aide de cet algorithme d&apos; accélérer notablement la recherche des solutions de ces problèmes par rapport à une « recherche brute » . des puzzles , cryptographiques comme « send + more = money » , ou numériques comme le sudoku . malgré tout , ce genre de problème est souvent de complexité exponentielle par rapport au nombre d&apos; éléments du problème ( typiquement , n = 2 ^ n si n est le nombre d&apos; éléments mis en jeu dans le problème ) . même si cet algorithme apporte une optimisation non négligeable ( quadratique ) par rapport à une recherche brute , il transforme un problème de complexité 2 ^ n en \ sqrt { 2 ^ n } = 2 ^ { n / 2 } , qui demeure exponentielle . certains algorithmes classiques , adaptés à un problème particulier , peuvent faire mieux , surtout si on tolère une solution approximative , ou probabiliste . mais cet algorithme présente le double avantage d&apos; être généraliste ( dès que l&apos; on a l&apos; algorithme pour vérifier une solution , on a automatiquement l&apos; algorithme pour trouver la solution ) , et de garantir de trouver la ou les solution ( s ) optimale ( s ) . il a été prouvé en 1999 , par christof zalkac zalka grover&apos; s quantum searching algorithm is optimal phys. rev . a , volume 60 issue 4 ( 1999 ) pp. 2476-2751 , que l&apos; algorithme de grover est l&apos; algorithme quantique le plus efficace pouvant traiter le problème de la recherche non structurée . il est impossible de faire mieux qu&apos; une amélioration quadratique de la complexité , en utilisant le parallélisme du calcul quantique . ceci est la limitation principale du calcul quantique , qui est en mesure de calculer simultanément 2 ^ n résultats , mais auxquels on ne peut avoir directement accès . tout algorithme quantique doit donc comporter une phase qui permet d&apos; exploiter et de mesurer les résultats , ce qui va venir grever les performances idéales que permettraient le parallélisme quantique . c&apos; est exactement ce qui va se passer pour l&apos; algorithme de grover . un algorithme d&apos; amplification d&apos; amplitude , qui permet de rendre exploitable et mesurable l&apos; information donnée par la boîte noire . cet algorithme est indépendant de la boîte noire , et c&apos; est cette procédure qui nécessite o ( \ sqrt n ) itérations . cette boîte noire est bien entendu en mesure d&apos; accepter une superposition d&apos; états en entrée , et donc de vérifier le critère simultanément pour tous les états de la superposition . en effet , la boîte noire est elle-même implémentée par un calcul quantique , qui est en mesure d&apos; opérer sur une superposition d&apos; un bout à l&apos; autre d&apos; algorithme qui détermine le critère . cliquez sur une vignette pour l ’ agrandir . l&apos; état peut être alors mesuré pour obtenir , avec une quasi-certitude , l&apos; état recherché . le nombre d&apos; itérations optimal est exactement de k = \ frac { \ pi } { 4 } \ sqrt { 2 ^ n } , n étant le nombre de qbits ( voir détermination du nombre d&apos; itérations optimal ) . au delà de ce nombre , la probabilité de détection commence à décroître . c&apos; est pourquoi c.p. williams , dans son livre explorations in quantum computing , aime citer l&apos; épouse d&apos; un informaticien quantique qui compare l&apos; algorithme de grover à la cuisson d&apos; un soufflé : il est nécessaire d&apos; arrêter l&apos; algorithme ni trop tôt ni trop tard . la probabilité de détecter la solution est non nulle dès la première itération et s&apos; accroît à chaque itération . serait-il possible d&apos; accélérer le processus en s&apos; arrêtant ( par exemple ) à \ frac k { 10 } itérations , vérifier si le résultat mesuré est une solution ( ce qui est rapide ) , sinon tout recommencer pour de nouveau \ frac k { 10 } itérations etc ... ? est-ce que , en moyenne , ce processus ne serait pas plus rapide que de faire à chaque fois le nombre d&apos; itérations optimal ? le calcul montre que cette stratégie nécessite , en moyenne , le même nombre d&apos; itérations que le nombre optimal , sans compter le coût de réinitialiser le dispositif à chaque échecparagraphe 5.6 « can grover&apos; s algorithm be beaten ? » . l&apos; algorithme de recherche de grover est très polyvalent : l&apos; opérateur qui identifie les solutions du problème ( l&apos; oracle ) étant clairement dissocié du reste de l&apos; algorithme , il peut être utilisé pour des problèmes très divers , et notamment pour les problèmes de complexité np ( voir introduction ) . on peut également utiliser l&apos; oracle à d&apos; autres niveaux , pour non pas rechercher directement des solutions , mais pour chercher des heuristiques de solutions . par exemple , il est en théorie possible d&apos; utiliser l&apos; algorithme de grover pour accélérer les algorithmes probabilistes classiquesparagraphe 5.7.1 « speeding up randomized algorithms » . dans un algorithme probabiliste , on utilise successivement plusieurs graines de générateur de nombres pseudo-aléatoires : certaines graines vont s&apos; orienter vers la solution , d&apos; autres graines vont faire diverger l&apos; algorithme . on s&apos; arrête après l&apos; essai successif d&apos; un certain nombre n de graines , dès qu&apos; une même solution semble être désignée par plusieurs graines , alors que les autres graines donnent des résultats très différents . l&apos; algorithme de grover peut donner les mêmes résultats , en exploitant une superposition de graines , en \ sqrt n étapes seulementa . carlini et a. hosota quantum probabilistic subroutines and problems in number theory phys . rev . a , volume 62 ( 2000 ) . dans un autre domaine , l&apos; algorithme de grover peut être utilisé , non pour faire des recherches de solution , mais uniquement pour ses capacités d&apos; amplification d&apos; amplitude . les chercheurs en physique quantique ont souvent le besoin de préparer objet quantique dans état particulier , ce qui est en général extrêmement difficile . l&apos; algorithme de grover permet de fabriquer un état quantique donné , en n&apos; amplifiant que les composantes voulues par l&apos; expérimentateurl.k grover synthesis of quantum superpositions by quantum computation phys . rev . lett . volume 85 issue 6 ( 2000 ) pp. 1334-1337 . il est en théorie , et en pratique , possible d&apos; utiliser l&apos; algorithme de grover lui-même dans l&apos; oracle , menant à une certaine forme de récursivité de l&apos; algorithme . cette forme de récursivité s&apos; applique particulièrement bien aux problèmes np-complets dont la recherche de solution s&apos; effectue souvent en descendant un arbre de rechercheparagraphe 7.4 « quantum solution using nested grover&apos; s algorithm » . au lieu de rechercher la solution parmi toutes les solutions terminales de l&apos; arbre , ce qui mène à une complexité brute de o \ left ( b ^ { \ frac \ mu 2 } \ right ) ( contre o \ left ( b ^ { \ mu } \ right ) pour un algorithme classique ) , il est possible d&apos; obtenir une complexité de o \ left ( b ^ { \ alpha \ frac \ mu 2 } \ right ) ( avec \ alpha un facteur inférieur ( voire très inférieur ) à un , dépendant du problème considéré ) en appliquant l&apos; algorithme de grover aux niveaux successifs de l&apos; arbre . la complexité demeure toujours exponentielle , mais l&apos; amélioration est telle que l&apos; algorithme quantique est alors en mesure d&apos; être meilleur que les meilleurs algorithmes classiques pour résoudre ces problèmes np-completsparagraphe 7.5 « summary » . \ hat o est l&apos; oracle ( u _ { \ omega } sur la figure ci-contre ) . \ hat h \ hat z \ hat h est appelé l &apos; opérateur de diffusion de grover . chaque amplitude est transformée c _ k \ rightarrow 2 \ bar c - c _ k ce qui constitue en effet un miroir de l&apos; amplitude autour de la moyenne des amplitudes . il existe plusieurs démonstrations du nombre optimal d&apos; itérations k = \ frac { \ pi } { 4 } \ sqrt { 2 ^ n } . les unes effectuent une interprétation géométrique de l&apos; opérateur de diffusion de grover , faisant apparaître une analogie entre cet opérateur et une rotation progressive du vecteur d&apos; état de l&apos; état initial vers l&apos; état cible . l&apos; état initial et l&apos; état cible étant orthogonaux , il suffit de compter le nombre de rotations pour aboutir à une rotation totale de \ frac \ pi 2voir par exemple 5.4.1 « how much amplitude amplification is needed to ensure success ? » . on peut également , plus algébriquement , calculer combien d&apos; inversions autour de la moyenne sont nécessaires pour aboutir à un maximum , en partant d&apos; une distribution uniforme \ frac 1 { \ sqrt { 2 ^ n } } . voici une démonstration du calcul du nombre d&apos; itérations , par la méthode géométriquevoir présentation de l&apos; algorithme de grover par le pr . raffaele solca . donc , l&apos; opérateur \ hat g effectue , dans cette représentation , une rotation d&apos; angle 2 \ theta , tel que \ theta = \ arcsin \ frac { 1 } { \ sqrt { 2 ^ n } } . m \ approx \ frac \ pi 4 \ sqrt { 2 ^ n } .
