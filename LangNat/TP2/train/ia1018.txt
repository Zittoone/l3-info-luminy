pour les articles homonymes , voir a * . l&apos; algorithme de recherche a * ( qui se prononce a étoile , ou a star à l&apos; anglaise ) est un algorithme de recherche de chemin dans un graphe entre un nœud initial et un nœud final tous deux donnés . de par sa simplicité il est souvent présenté comme exemple typique d&apos; algorithme de planification , domaine de l&apos; intelligence artificielle . l&apos; algorithme a * a été créé pour que la première solution trouvée soit l&apos; une des meilleures , c&apos; est pourquoi il est célèbre dans des applications comme les jeux vidéo privilégiant la vitesse de calcul sur l&apos; exactitude des résultats . cet algorithme a été proposé pour la première fois par peter e. hart ( en ) catégorie : article contenant un appel à traduction en anglais , nils john nilsson ( en ) catégorie : article contenant un appel à traduction en anglais et bertram raphael ( en ) catégorie : article contenant un appel à traduction en anglais en 1968template : article . il s&apos; agit d&apos; une extension de l&apos; algorithme de dijkstra de 1959 . en 1968 , le chercheur en intelligence artificielle nils nilsson essayait d&apos; améliorer le planification de shakey le robot , un robot prototype qui se déplace dans une pièce avec des obstacles . l&apos; algorithme pour trouver un chemin , que nilsson appelait a1 , était une version plus rapide que la méthode la plus connue à l&apos; époque , l&apos; algorithme de dijkstra , pour trouver des plus courts chemins dans un graphe . bertram raphael a suggéré des améliorations , donnant lieu à la version révisée a2 . puis , peter e. hart a apporté des améliorations mineures à a2 . hart , nilsson et raphael ont alors montré que a2 est optimal pour trouver des plus courts chemins sous certaines conditions . l&apos; algorithme a * est un algorithme de recherche de chemin dans un graphe entre un nœud initial et un nœud final . il utilise une évaluation heuristique sur chaque nœud pour estimer le meilleur chemin y passant , et visite ensuite les nœuds par ordre de cette évaluation heuristique . c&apos; est un algorithme simple , ne nécessitant pas de prétraitement , et ne consommant que peu de mémoire . commençons par un exemple de motivation . on se trouve à l&apos; intersection a et on veut se rendre à l&apos; intersection b dont on sait qu&apos; elle se trouve au nord de notre position actuelle . pour ce cas classique , le graphe sur lequel l&apos; algorithme va travailler représente la carte , où ses arcs représentent les chemins et ses nœuds les intersections des chemins . si on faisait une recherche en largeur comme le réalise l&apos; algorithme de dijkstra , on rechercherait tous les points dans un rayon circulaire fixe , augmentant graduellement ce cercle pour rechercher des intersections de plus en plus loin de notre point de départ . ceci pourrait être une stratégie efficace si on ne savait pas où se trouve notre destination , comme la police recherchant un criminel en planque . cependant , c&apos; est une perte de temps si on connaît plus d&apos; informations sur notre destination . une meilleure stratégie est d&apos; explorer à chaque intersection la première directement qui va vers le nord , car le chemin le plus court est la ligne droite . tant que la route le permet , on continue à avancer en prenant les chemins se rapprochant le plus de l&apos; intersection b. certainement devra-t-on revenir en arrière de temps en temps , mais sur les cartes typiques c&apos; est une stratégie beaucoup plus rapide . d&apos; ailleurs , souvent cette stratégie trouvera le meilleur itinéraire , comme la recherche en largeur le ferait . c&apos; est l&apos; essence de la recherche de chemin a * . toutefois , comme pour tous les algorithmes de recherche de chemin , leur efficacité dépend fortement du problème que l&apos; on souhaite résoudre ( c&apos; est-à-dire : du graphe ) . ainsi l&apos; algorithme a * ne garantit pas de trouver un itinéraire plus rapidement qu&apos; un autre algorithme , et dans un labyrinthe , la seule manière d&apos; atteindre la destination pourrait être à l&apos; opposé de la position de la destination , et les nœuds les plus proches de cette destination pourraient ne pas être sur le chemin le plus court , ce qui peut coûter beaucoup de temps de calcul . un algorithme de recherche qui garantit de toujours trouver le chemin le plus court à un but s&apos; appelle « algorithme admissible » . si a * utilise une heuristique qui ne surestime jamais la distance ( ou plus généralement le coût ) du but , a * peut être avéré admissible . une heuristique qui rend a * admissible est elle-même appelée « heuristique admissible » . si l&apos; évaluation renvoie simplement toujours zéro , qui n&apos; est jamais une surestimation , alors , a * exécutera une implémentation possible de l&apos; algorithme de dijkstra et trouvera toujours la solution optimale . la meilleure heuristique , bien qu&apos; habituellement impraticable pour calculer , est la distance minimale réelle ( ou plus généralement le coût réel ) au but . un exemple d&apos; une heuristique admissible pratique est la distance à vol d&apos; oiseau du but sur la carte . on peut démontrer que a * ne considère pas plus de nœuds que tous les autres algorithmes admissibles de recherche , à condition que l&apos; algorithme alternatif n&apos; ait pas une évaluation heuristique plus précise . dans ce cas , a * est l&apos; algorithme informatique le plus efficace garantissant de trouver le chemin le plus court . a * commence à un nœud choisi . il applique à ce nœud un « coût » ( habituellement zéro pour le nœud initial ) . a * estime ensuite la distance qui sépare ce nœud du but à atteindre . la somme du coût et de l&apos; évaluation représente le coût heuristique assigné au chemin menant à ce nœud . le nœud est alors ajouté à une file d&apos; attente prioritaire , couramment appelée open list . l&apos; algorithme retire le premier nœud de la file d&apos; attente prioritaire ( dû au fonctionnement d&apos; une file d&apos; attente , le nœud à l&apos; heuristique la plus basse est retiré en premier ) . si la file d&apos; attente est vide , il n&apos; y a aucun chemin du nœud initial au nœud d&apos; arrivée , ce qui interrompt l&apos; algorithme . si le nœud retenu est le nœud d&apos; arrivée , a * reconstruit le chemin complet et s&apos; arrête . pour cette reconstruction on se sert d&apos; une partie des informations sauvées dans la liste communément appelé closed list décrite plus bas . si le nœud n&apos; est pas le nœud d&apos; arrivée , de nouveaux nœuds sont créés pour tous les nœuds contigus admissibles ; la manière exacte de faire dépend du problème à traiter . pour chaque nœud successif , a * calcule son coût et le stocke avec le nœud . ce coût est calculé à partir de la somme du coût de son ancêtre et du coût de l&apos; opération pour atteindre ce nouveau nœud . l&apos; algorithme maintient également la liste de nœuds qui ont été vérifiés , couramment appelée closed list . si un nœud nouvellement produit est déjà dans cette liste avec un coût égal ou inférieur , aucune opération n&apos; est faite sur ce nœud ni sur son homologue se trouvant dans la liste . après , l&apos; évaluation de la distance du nouveau nœud au nœud d&apos; arrivée est ajoutée au coût pour former l&apos; heuristique du nœud . ce nœud est alors ajouté à la liste d&apos; attente prioritaire , à moins qu&apos; un nœud identique dans cette liste ne possède déjà une heuristique inférieure ou égale . une fois les trois étapes ci-dessus réalisées pour chaque nouveau nœud contigu , le nœud original pris de la file d&apos; attente prioritaire est ajouté à la liste des nœuds vérifiés . le prochain nœud est alors retiré de la file d&apos; attente prioritaire et le processus recommence . les deux structures open list et closed list ne sont pas nécessaires si on peut garantir que le premier chemin produit à n&apos; importe quel nœud est le plus court . cette situation surgit si l&apos; heuristique est non seulement admissible mais aussi « monotone » , signifiant que la différence entre l&apos; heuristique de deux nœuds quelconques reliés ne surestime pas la distance réelle entre ces nœuds . ce n&apos; est possible que dans de très rares cas . voici une implémentation possible de l&apos; algorithme , en pseudocode , pour une recherche de chemin dans une carte qui est un tableau à deux dimensions tel que chaque case contient un état : traversable ou non .
