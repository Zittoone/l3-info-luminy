la méthode de viola et jones est une méthode de détection d&apos; objet dans une image numérique , proposée par les chercheurs paul viola et michael jones en 2001 . elle fait partie des toutes premières méthodes capables de détecter efficacement et en temps réel des objets dans une image . inventée à l&apos; origine pour détecter des visages , elle peut également être utilisée pour détecter d&apos; autres types d&apos; objets comme des voitures ou des avions . la méthode de viola et jones est l&apos; une des méthodes les plus connues et les plus utilisées , en particulier pour la détection de visages et la détection de personnes . en tant que procédé d&apos; apprentissage supervisé , la méthode de viola et jones nécessite de quelques centaines à plusieurs milliers d&apos; exemples de l&apos; objet que l&apos; on souhaite détecter , pour entraîner un classifieur . une fois son apprentissage réalisé , ce classifieur est utilisé pour détecter la présence éventuelle de l&apos; objet dans une image en parcourant celle-ci de manière exhaustive , à toutes les positions et dans toutes les tailles possibles . considérée comme étant l&apos; une des plus importantes méthodes de détection d&apos; objet , la méthode de viola et jones est notamment connue pour avoir introduit plusieurs notions reprises ensuite par de nombreux chercheurs en vision par ordinateur , à l&apos; exemple de la notion d&apos; image intégrale ou de la méthode de classification construite comme une cascade de classifieurs boostés . cette méthode bénéficie d&apos; une implémentation sous licence bsd dans opencv , une bibliothèque très utilisée en vision par ordinateur . paul viola et michael jones , alors employés au cambridge research laboratory de la société américaine compaqtemplate : en template : lien web . , publient la méthode qui porte leur nom pour la première fois le &lt; time class = &quot; nowrap date-lien &quot; datetime = &quot; 2001-07-13 &quot; &gt; 13 juillet 2001 &lt; / time &gt; dans le journal scientifique international journal of computer vision ( ijcv ) template : article . . les deux auteurs publient ensuite deux autres articles sur la méthode : une version moins détaillée , présentée à la conference on computer vision and pattern recognition ( cvpr ) en décembre 2001template : article. et une version révisée en 2004 , toujours dans ijcvtemplate : article . . les caractéristiques extraites par cette méthode sont inspirées des travaux de papageorgiou , oren et poggio , datant de 1998template : article . , , qui utilisent des caractéristiques construites à partir d&apos; ondelettes de haar . la méthode s&apos; inspire également de précédents travaux de paul viola et kinh tieu dans un autre domaine , celui de la recherche d&apos; image par le contenu , en reprenant l&apos; idée de sélection de caractéristiques par adaboosttemplate : article . , . parmi les nombreuses méthodes de détection de visages publiées à l&apos; époquetemplate : article . , viola et jones considèrent en particulier celle de rowley-kanade : en raison de ses excellents résultats et de sa rapidité , ils la prennent comme référence pour les comparaisons . à performances équivalentes , viola et jones notent que la détection par leur méthode est 15 fois plus rapide que le détecteur de rowley-kanade . la méthode , considérée comme l&apos; une des plus efficaces en détection de visage , devient rapidement un standard dans ce domaineszeliski ( 2010 ) , template : p. . . les travaux de viola et jones sont parmi les plus utilisés et les plus cités par les chercheurs , et de nombreuses améliorations sont ainsi proposées , template : article . . leurs travaux sont également étendus à d&apos; autres types d&apos; objets que les visages et la méthode devient ainsi un standard en détection d&apos; objet . la méthode est par ailleurs reconnue comme étant celle ayant eu le plus d&apos; impact dans le domaine de la détection de visage dans les années 2000template : article . . la méthode de viola et jones est une approche basée sur l&apos; apparenceszeliski ( 2010 ) template : p. . , qui consiste à parcourir l&apos; ensemble de l&apos; image en calculant un certain nombre de caractéristiques dans des zones rectangulaires qui se chevauchent . elle a la particularité d&apos; utiliser des caractéristiques très simples mais très nombreuses . une première innovation de la méthode est l&apos; introduction des images intégrales , qui permettent le calcul rapide de ces caractéristiques . une deuxième innovation importante est la sélection de ces caractéristiques par boosting , en interprétant les caractéristiques comme des classifieurs . enfin , la méthode propose une architecture pour combiner les classifieurs boostés en un processus en cascade , ce qui apporte un net gain en temps de détection . la méthode , en tant que méthode d&apos; apprentissage supervisé , est divisée en deux étapes : une étape d&apos; apprentissage du classifieur basé sur un grand nombre d&apos; exemples positifs ( c&apos; est-à-dire les objets d&apos; intérêt , par exemple des visages ) et d&apos; exemples négatifs , et une phase de détection par application de ce classifieur à des images inconnues . plutôt que de travailler directement sur les valeurs de pixels , et pour être à la fois plus efficace et plus rapide , viola et jones proposent d&apos; utiliser des caractéristiques , c&apos; est-à-dire une représentation synthétique et informative , calculée à partir des valeurs des pixels . viola et jones définissent des caractéristiques très simples , les caractéristiques pseudo-haar , qui sont calculées par la différence des sommes de pixels de deux ou plusieurs zones rectangulaires adjacentes . la figure ci-contre donne des exemples des caractéristiques proposées par viola et jones à 2 , 3 ou 4 rectangles , dans lesquelles la somme de pixels sombres est soustraite de la somme des pixels blancs . leur nom vient de leur similitude avec les ondelettes de haar , précédemment proposées comme caractéristiques par papageorgiou et dont se sont inspirés viola et jones . grâce à cette représentation , une caractéristique formée de deux zones rectangulaires peut être calculée en seulement 6 accès à l&apos; image intégrale , et donc en un temps constant quelle que soit la taille de la caractéristique . les caractéristiques sont calculées à toutes les positions et à toutes les échelles dans une fenêtre de détection de petite taille , typiquement de 24 × 24 pixels ou de 20 × 15 pixelstemplate : article . . un très grand nombre de caractéristiques par fenêtre est ainsi généré , viola et jones donnant l&apos; exemple d&apos; une fenêtre de taille 24 × 24 qui génère environ 160 000 caractéristiques . en phase de détection , l&apos; ensemble de l&apos; image est parcouru en déplaçant la fenêtre de détection d&apos; un certain pas dans le sens horizontal et vertical ( ce pas valant 1 pixel dans l&apos; algorithme original ) . les changements d&apos; échelles se font en modifiant successivement la taille de la fenêtre de détectionles méthodes alternatives recourent principalement à la construction d&apos; une pyramide d&apos; images . . viola et jones utilisent un facteur multiplicatif de 1,25 , jusqu&apos; à ce que la fenêtre couvre la totalité de l&apos; image . finalement , et afin d&apos; être plus robuste aux variations d&apos; illumination , les fenêtres sont normalisées par la variance . la conséquence de ces choix techniques , notamment le recours aux images intégrales , est un gain notable en efficacité , les caractéristiques étant évaluées très rapidement quelle que soit la taille de la fenêtre . le deuxième élément clé de la méthode de viola et jones est l&apos; utilisation d&apos; une méthode de boosting afin de sélectionner les meilleures caractéristiques . le boosting est un principe qui consiste à construire un classifieur « fort » à partir d&apos; une combinaison pondérée de classifieurs « faibles » , c&apos; est-à-dire donnant en moyenne une réponse meilleure qu&apos; un tirage aléatoire . viola et jones adaptent ce principe en assimilant une caractéristique à un classifieur faible , en construisant un classifieur faible qui n&apos; utilise qu&apos; une seule caractéristique . l&apos; apprentissage du classifieur faible consiste alors à trouver la valeur seuil de la caractéristique qui permet de mieux séparer les exemples positifs des exemples négatifs . le classifieur se réduit alors à un couple ( caractéristique , seuil ) . l&apos; algorithme de boosting utilisé est en pratique une version modifiée d&apos; adaboost , qui est utilisée à la fois pour la sélection et pour l&apos; apprentissage d&apos; un classifieur « fort » . les classifieurs faibles utilisés sont souvent des arbres de décision . un cas remarquable , fréquemment rencontré , est celui de l&apos; arbre de profondeur 1 , qui réduit l&apos; opération de classification à un simple seuillage . l&apos; algorithme est de type itératif , à nombre d&apos; itérations déterminé . à chaque itération , l&apos; algorithme sélectionne une caractéristique , qui sera ajoutée à la liste des caractéristiques sélectionnées aux itérations précédentes , et le tout va contribuer à la construction du classifieur fort final . cette sélection se fait en entraînant un classifieur faible pour toutes les caractéristiques et en sélectionnant celui avec l&apos; erreur la plus faible sur l&apos; ensemble d&apos; apprentissage . l&apos; algorithme tient également à jour une distribution de probabilité sur l&apos; ensemble d&apos; apprentissage , réévaluée à chaque itération en fonction des résultats de classification . en particulier , plus de poids est attribué aux exemples difficiles à classer , c&apos; est-à-dire ceux dont l&apos; erreur est élevée . le classifieur « fort » final construit par adaboost est composé de la somme pondérée des classifieurs sélectionnés. les w _ i étant les poids associés à chaque exemple et mis à jour à chaque itération en fonction de l&apos; erreur obtenue à l&apos; itération précédente . on sélectionne alors à l&apos; itération t le classifieur h _ t présentant l&apos; erreur la plus faible : \ epsilon _ t = \ min _ j ( \ epsilon _ j ) . les \ alpha _ t sont des coefficients calculés à partir de l&apos; erreur \ epsilon _ t. la méthode de viola et jones est basée sur une approche par recherche exhaustive sur l&apos; ensemble de l&apos; image , qui teste la présence de l&apos; objet dans une fenêtre à toutes les positions et à plusieurs échelles . cette approche est cependant extrêmement coûteuse en calcul . l&apos; une des idées-clés de la méthode pour réduire ce coût réside dans l&apos; organisation de l&apos; algorithme de détection en une cascade de classifieurs . appliqués séquentiellement , ces classifieurs prennent une décision d&apos; acceptation — la fenêtre contient l&apos; objet et l&apos; exemple est alors passé au classifieur suivant — , ou de rejet — la fenêtre ne contient pas l&apos; objet et dans ce cas l&apos; exemple est définitivement écarté — . l&apos; idée est que l&apos; immense majorité des fenêtres testées étant négatives ( c.-à-d. ne contiennent pas l&apos; objet ) , il est avantageux de pouvoir les rejeter avec le moins possible de calculs . ici , les classifieurs les plus simples , donc les plus rapides , sont situés au début de la cascade , et rejettent très rapidement la grande majorité des exemples négatifs . cette structure en cascade peut également s&apos; interpréter comme un arbre de décision dégénéré , puisque chaque nœud ne comporte qu&apos; une seule branche . en pratique , la cascade est constituée d&apos; une succession d&apos; étageson utilise parfois le terme de « couche » pour désigner un étage . , chacune étant formée d&apos; un classifieur fort appris par adaboost . l&apos; apprentissage du classifieur de l&apos; étage n est réalisé avec les exemples qui ont passé l&apos; étage n-1 ; ce classifieur doit donc faire face à un problème plus difficile : plus on monte dans les étages , plus les classifieurs sont complexes . en pratique , les taux d _ i et f _ i sont les mêmes pour tous les étages . indirectement , ces taux déterminent également le nombre de caractéristiques utilisées par les classifieurs forts à chaque étage : les itérations d&apos; adaboost continuent jusqu&apos; à ce que le taux de fausse alarme cible soit atteint . des caractéristiques / classifieurs faibles sont ajoutés jusqu&apos; à ce que les taux cibles soient atteints , avant de passer ensuite à l&apos; étage suivant . pour atteindre des taux de détection et de fausse alarme corrects en fin de cascade , il est nécessaire que les classifieurs forts de chaque étage aient un bon taux de détection ; ils peuvent par contre avoir un taux de fausses alarmes élevé . si l&apos; on prend l&apos; exemple d&apos; une cascade de 32 étages , pour obtenir une performance finale d = 0.9 et f = 10 ^ { -6 } , chaque classifieur fort doit atteindre d _ i = 0,997 , mais peut se permettre f _ i = 0,65 ( i.e. 0,65 ^ { 32 } = 10 ^ { -6 } et 0,997 ^ { 32 } = 0,9 ) . chaque étage ajouté diminue donc le nombre de fausses alarmes , mais aussi le taux de détection . plusieurs chercheurs font remarquer que cette idée de filtrer rapidement les exemples négatifs les plus simples n&apos; est pas nouvelletemplate : article . , . elle existe dans d&apos; autres méthodes sous forme d&apos; heuristiques , comme la détection de la couleur chairtemplate : article . , template : article. ou une étape de pré-classification . l&apos; entraînement de la cascade : à chaque étage de la cascade , un classifieur fort est entraîné par adaboost . il est construit par ajouts successifs de classifieurs faibles entraînés sur une seule caractéristique , jusqu&apos; à l&apos; obtention de performances conformes aux taux de détection et de fausse alarme souhaités pour l&apos; étage. fusion des détections multiples : l&apos; objet peut en effet générer plusieurs détections , à différentes positions et échelles ; cette dernière étape fusionne les détections qui se chevauchent pour ne retourner qu&apos; un seul résultat . viola et jones ont testé leur algorithme sur la base de visages mit + cmu , constituée de 130 images contenant 507 visages de facetemplate : article . . ils présentent leur résultat sous la forme d&apos; une courbe receiver operating characteristic ( roc ) , qui donne le taux de détection correct en fonction du nombre de fausses alarmes total sur toutes les images du corpus . à titre d&apos; exemple , pour 50 fausses alarmes , ils obtiennent un taux de détection de 88,8 % . viola et jones comparent également les performances de leur méthode aux détecteurs de visages existants , notamment celui de rowley-kanade . ils constatent que les résultats sont globalement proches des autres détecteurs , quoique légèrement inférieures aux résultats de rowley-kanade pour un faible nombre de fausses alarmes , et légèrement supérieurs pour un nombre de fausses alarmes élevées . la rapidité de détection , pour sa part , dépend directement du nombre de caractéristiques évaluées , donc du contenu de l&apos; image . sur un pc pentium iii cadencé à 700 mhz , les auteurs rapportent un temps de traitement moyen de 0,067 secondes pour une image de taille 384 × 288 pixels , correspondant à débit moyen de 15 images par seconde , assez proche des exigences du traitement vidéo en temps réel ( soit 25 images par seconde ) . finalement , sur la base de visages mit + cmu , leur détecteur est 15 fois plus rapide que celui de rowley-kanade et 600 fois plus rapide que celui de schneiderman-kanade , pour des taux de détection et de fausse alarme comparables . de très nombreuses améliorations ont été proposées par la suite , visant à améliorer le paramétrage de la méthode , ou à en combler un certain nombre de limitations . l&apos; une des premières améliorations est apportée par lienhart et maydt en 2002template : article . . ils proposent d&apos; étendre l&apos; ensemble de caractéristiques pseudo-haar utilisé de 4 à 14 caractéristiques . de même , ils introduisent des caractéristiques « de biais » ( tournées de 45 ° ) , ainsi qu&apos; une méthode pour les calculer basée sur une extension des images intégrales . d&apos; autres types de caractéristiques ont également été utilisées en remplacement des caractéristiques de haar : les histogrammes de gradients orientéstemplate : article . , les motifs binaires locaux ou la covariance de régiontemplate : article . . les chercheurs ont également proposé d&apos; utiliser des variantes de l&apos; algorithme de boosting , notamment realboost , qui produit un indice de confiance à valeurs réelles , en plus de la classificationtemplate : article . . plusieurs travaux ont ainsi montré la supériorité de realboost sur adaboost dans le cadre de l&apos; algorithme de viola et jones , template : article . viola et jones étendent en 2003 leur système à la détection de piétons dans des vidéos , en incluant une information de mouvement en plus de l&apos; information d&apos; apparence . une des limitations de la méthode est son manque de robustesse à la rotation , et sa difficulté à apprendre plusieurs vues d&apos; un même objet . en particulier , il est difficile d&apos; obtenir un classifieur capable de détecter à la fois des visages de face et de profil . viola et jones ont proposé une amélioration qui permet de corriger ce défauttemplate : article . , qui consiste à apprendre une cascade dédiée à chaque orientation ou vue , et à utiliser lors de la détection un arbre de décision pour sélectionner la bonne cascade à appliquer . plusieurs autres améliorations ont été proposées par la suite pour apporter une solution à ce problèmetemplate : chapitre . , . une autre limitation importante de la méthode de viola et jones concerne le temps d&apos; apprentissage de la cascade , compris généralement entre plusieurs jours et plusieurs semaines de calcul , szeliski ( 2010 ) , template : p. . , ce qui limite sévèrement les possibilités de tests et de choix des paramètrestemplate : article . . un des problèmes majeurs de la méthode proposée par viola et jones est qu&apos; il n&apos; existe pas de méthode optimale pour choisir les différents paramètres régissant l&apos; algorithme : le nombre d&apos; étages , leur ordre ou les taux de détection et de fausses alarmes pour chaque étage doivent être choisis par essais et erreurs , template : article . . plusieurs méthodes sont proposées pour déterminer certains de ces seuils de manière automatique , , template : article . . un reproche également fait à la méthode concerne la perte d&apos; information subie au passage d&apos; un étage à l&apos; autre de la cascade , perte due à l&apos; effet couperet des décisions d&apos; acceptation ou de rejet prises à chaque étage . certains chercheurs proposent la solution de garder l&apos; information contenue dans la somme pondérée des classifieurs faibles , par exemple le « boosting chain » de xiaotemplate : article . . une modification plus radicale de structure est proposée par bourdev et sa notion de cascade souple , qui consiste essentiellement à supprimer le concept d&apos; étages , en formant un seul classifieur fort , donc une seule somme , et en permettant de prendre une décision à chaque évaluation de classifieur faible et de s&apos; affranchir de la contrainte des taux de détection et de fausses alarmes cibles . la méthode de viola et jones a essentiellement été appliquée à la détection de visage et à la détection de personne , principalement en raison des nombreuses applications pratiques qu&apos; offrent ces deux domaines , notamment en vidéosurveillance , en indexation d&apos; images et de vidéo ou pour les interfaces homme-machine multimodalestemplate : article . . un exemple d&apos; application grand public de la méthode est donné par les appareils photographiques numériques , où elle sert à effectuer la mise au point automatique sur les visages . combinée avec le standard jpeg 2000 , la méthode peut également servir à compresser les visages avec un taux de compression plus faible que le reste de l&apos; image , afin de préserver les détails des visagestemplate : chapitre . . les constructeurs automobiles s&apos; intéressent également à la méthode pour concevoir des systèmes de sécurité capables de détecter automatiquement les autres usagers de la route , en particulier les piétonstemplate : chapitre . . des recherches ont également montré que l&apos; efficacité de la méthode ne se limite pas au domaine visible , mais qu&apos; elle s&apos; étend également au domaine infrarougetemplate : article . . la méthode de viola et jones a également été utilisée pour détecter d&apos; autres types d&apos; objets , par exemple des mains , pour la commande gestuelle d&apos; une interface homme-machinetemplate : article . , des voitures dans des images satellites pour la création de systèmes d&apos; information géographique débarrassés de toute présence visuelle d&apos; automobilestemplate : chapitre . , ou pour l&apos; évaluation et le suivi du trafic routiertemplate : article . . la méthode a également été évaluée pour la détection d&apos; avions dans des images de basse résolution à partir d&apos; une caméra embarquée dans un véhicule aérien , pour l&apos; évitement de collisionstemplate : article . . des applications militaires existent aussi pour la détection de cibles ( chars , avions ) dans des images aériennes ou satellitairestemplate : ouvrage . . il existe de nombreuses implémentations du détecteur de viola et jones , la plus utilisée étant celle en c + + présente dans la libraire de vision par ordinateur opencv , publiée sous licence bsd . des implémentations ont été développées pour des environnements ou plates-formes spécifiques , notamment pour une exécution dans des navigateurs web en utilisant le langage de script actionscript du logiciel multimédia flashtemplate : chapitre . . des implémentations matérielles ont également été développées sur asictemplate : chapitre . , fpgatemplate : chapitre. et sur gputemplate : chapitre . . l&apos; utilisation de l&apos; architecture parallèle de ces derniers permet un net gain de temps de détection par rapport à l&apos; implémentation opencv traditionnelle . enfin , les implémentations les plus courantes sont celles rencontrées dans les appareils photographiques numériques pour la mise au point automatique par la détection de visagetemplate : chapitre . . elles nécessitent des optimisations particulières pour faire face à la faible puissance de calcul de ce type de matériel .
